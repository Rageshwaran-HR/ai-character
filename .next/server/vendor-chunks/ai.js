"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nanoid */ \"(ssr)/./node_modules/nanoid/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/utils.ts\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessage = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlData = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessage,\n    assistantControlData\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessage.code]: assistantMessage,\n    [assistantControlData.code]: assistantControlData\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessage.name]: assistantMessage.code,\n    [assistantControlData.name]: assistantControlData.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/utils.ts\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// shared/call-api.ts\n\n// shared/parse-complex-response.ts\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId = nanoid, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const decode = createChunkDecoder(true);\n    const prefixMap = {\n        data: []\n    };\n    const NEWLINE = \"\\n\".charCodeAt(0);\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        let concatenatedChunks = new Uint8Array(totalLength);\n        let offset = 0;\n        for (const chunk of chunks){\n            concatenatedChunks.set(chunk, offset);\n            offset += chunk.length;\n        }\n        chunks.length = 0;\n        totalLength = 0;\n        const lines = decode(concatenatedChunks);\n        if (typeof lines === \"string\") {\n            throw new Error(\"Invalid response format. Complex mode was set but the response is a string. This should never happen.\");\n        }\n        for (const { type, value: value2 } of lines){\n            if (type === \"text\") {\n                if (prefixMap[\"text\"]) {\n                    prefixMap[\"text\"] = {\n                        ...prefixMap[\"text\"],\n                        content: (prefixMap[\"text\"].content || \"\") + value2\n                    };\n                } else {\n                    prefixMap[\"text\"] = {\n                        id: generateId(),\n                        role: \"assistant\",\n                        content: value2,\n                        createdAt\n                    };\n                }\n            }\n            let functionCallMessage = null;\n            if (type === \"function_call\") {\n                prefixMap[\"function_call\"] = {\n                    id: generateId(),\n                    role: \"assistant\",\n                    content: \"\",\n                    function_call: value2.function_call,\n                    name: value2.function_call.name,\n                    createdAt\n                };\n                functionCallMessage = prefixMap[\"function_call\"];\n            }\n            if (type === \"data\") {\n                prefixMap[\"data\"].push(...value2);\n            }\n            const responseMessage = prefixMap[\"text\"];\n            const merged = [\n                functionCallMessage,\n                responseMessage\n            ].filter(Boolean);\n            update(merged, [\n                ...prefixMap[\"data\"]\n            ]);\n            if ((abortControllerRef == null ? void 0 : abortControllerRef.current) === null) {\n                reader.cancel();\n                break;\n            }\n        }\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/call-api.ts\nasync function callApi({ api, messages, body, credentials, headers, abortController, appendMessage, restoreMessagesOnFailure, onResponse, onUpdate, onFinish }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers,\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    const isComplexMode = response.headers.get(COMPLEX_HEADER) === \"true\";\n    if (isComplexMode) {\n        return await parseComplexResponse({\n            reader,\n            abortControllerRef: abortController != null ? {\n                current: abortController()\n            } : void 0,\n            update: onUpdate,\n            onFinish (prefixMap) {\n                if (onFinish && prefixMap.text != null) {\n                    onFinish(prefixMap.text);\n                }\n            }\n        });\n    } else {\n        const createdAt = /* @__PURE__ */ new Date();\n        const decode = createChunkDecoder(false);\n        let streamedResponse = \"\";\n        const replyId = (0,nanoid__WEBPACK_IMPORTED_MODULE_3__.nanoid)();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            streamedResponse += decode(value);\n            if (streamedResponse.startsWith('{\"function_call\":')) {\n                responseMessage[\"function_call\"] = streamedResponse;\n            } else {\n                responseMessage[\"content\"] = streamedResponse;\n            }\n            appendMessage({\n                ...responseMessage\n            });\n            if ((abortController == null ? void 0 : abortController()) === null) {\n                reader.cancel();\n                break;\n            }\n        }\n        if (streamedResponse.startsWith('{\"function_call\":')) {\n            const parsedFunctionCall = JSON.parse(streamedResponse).function_call;\n            responseMessage[\"function_call\"] = parsedFunctionCall;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if (message.function_call === void 0 || typeof message.function_call === \"string\") {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if (streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                updateChatRequest(functionCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call })=>({\n            role,\n            content,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = nanoid();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            }\n        },\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        appendMessage (message) {\n            mutate([\n                ...chatRequest.messages,\n                message\n            ], false);\n        },\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, onResponse, onFinish, onError, credentials, headers, body } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const chatId = id || hookId;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        chatId\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatId,\n        \"streamData\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        messagesRef.current,\n        abortControllerRef.current\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, data } = {})=>{\n        if (!message.id) {\n            message.id = nanoid();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController2 = new AbortController();\n            setAbortController(abortController2);\n            mutate(\"\", false);\n            const res = await fetch(api, {\n                method: \"POST\",\n                body: JSON.stringify({\n                    prompt,\n                    ...extraMetadataRef.current.body,\n                    ...options == null ? void 0 : options.body\n                }),\n                credentials: extraMetadataRef.current.credentials,\n                headers: {\n                    ...extraMetadataRef.current.headers,\n                    ...options == null ? void 0 : options.headers\n                },\n                signal: abortController2.signal\n            }).catch((err)=>{\n                throw err;\n            });\n            if (onResponse) {\n                try {\n                    await onResponse(res);\n                } catch (err) {\n                    throw err;\n                }\n            }\n            if (!res.ok) {\n                throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n            }\n            if (!res.body) {\n                throw new Error(\"The response body is empty.\");\n            }\n            let result = \"\";\n            const reader = res.body.getReader();\n            const decoder = createChunkDecoder();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                result += decoder(value);\n                mutate(result, false);\n                if (abortController2 === null) {\n                    reader.cancel();\n                    break;\n                }\n            }\n            if (onFinish) {\n                onFinish(prompt, result);\n            }\n            setAbortController(null);\n            return result;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                setAbortController(null);\n                return null;\n            }\n            if (err instanceof Error) {\n                if (onError) {\n                    onError(err);\n                }\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading\n    };\n}\n// react/use-assistant.ts\n\n// shared/process-message-stream.ts\nasync function processMessageStream(reader, processMessage) {\n    const decoder = new TextDecoder();\n    let buffer = \"\";\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            if (buffer.length > 0) {\n                processMessage(buffer);\n            }\n            break;\n        }\n        buffer += decoder.decode(value, {\n            stream: true\n        });\n        let endIndex;\n        while((endIndex = buffer.indexOf(\"\\n\")) !== -1){\n            processMessage(buffer.substring(0, endIndex).trim());\n            buffer = buffer.substring(endIndex + 1);\n        }\n    }\n}\n// react/use-assistant.ts\nfunction experimental_useAssistant({ api, threadId: threadIdParam }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    const submitMessage = async (e)=>{\n        var _a;\n        e.preventDefault();\n        if (input === \"\") {\n            return;\n        }\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>[\n                ...messages2,\n                {\n                    id: \"\",\n                    role: \"user\",\n                    content: input\n                }\n            ]);\n        setInput(\"\");\n        const result = await fetch(api, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                // always use user-provided threadId when available:\n                threadId: (_a = threadIdParam != null ? threadIdParam : threadId) != null ? _a : null,\n                message: input\n            })\n        });\n        if (result.body == null) {\n            throw new Error(\"The response body is empty.\");\n        }\n        await processMessageStream(result.body.getReader(), (message)=>{\n            try {\n                const { type, value } = parseStreamPart(message);\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            setError(value);\n                            break;\n                        }\n                }\n            } catch (error2) {\n                setError(error2);\n            }\n        });\n        setStatus(\"awaiting_message\");\n    };\n    return {\n        messages,\n        input,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztxR0FFQSxvQkFBb0I7QUFDb0Q7QUFDL0M7QUFFekIsa0JBQWtCO0FBQ2lDO0FBRW5ELHlCQUF5QjtBQUN6QixJQUFJTyxpQkFBaUI7SUFDbkJDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQVFGO1FBQU07SUFDL0I7QUFDRjtBQUNBLElBQUlHLHlCQUF5QjtJQUMzQk4sTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsb0JBQW1CQSxLQUFJLEtBQU0sT0FBT0EsTUFBTUksYUFBYSxLQUFLLFlBQVlKLE1BQU1JLGFBQWEsSUFBSSxRQUFRLENBQUUsV0FBVUosTUFBTUksYUFBYSxLQUFLLENBQUUsZ0JBQWVKLE1BQU1JLGFBQWEsS0FBSyxPQUFPSixNQUFNSSxhQUFhLENBQUNOLElBQUksS0FBSyxZQUFZLE9BQU9FLE1BQU1JLGFBQWEsQ0FBQ0MsU0FBUyxLQUFLLFVBQVU7WUFDelUsTUFBTSxJQUFJSixNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJTSxpQkFBaUI7SUFDbkJULE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxDQUFDTyxNQUFNQyxPQUFPLENBQUNSLFFBQVE7WUFDekIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQVFGO1FBQU07SUFDL0I7QUFDRjtBQUNBLElBQUlTLGtCQUFrQjtJQUNwQlosTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJ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QVk7NEJBQ25FOzRCQUNBO3dCQUNGO29CQUNBLEtBQUs7d0JBQVM7NEJBQ1pQLFNBQVNwSjs0QkFDVDt3QkFDRjtnQkFDRjtZQUNGLEVBQUUsT0FBT3VNLFFBQVE7Z0JBQ2ZuRCxTQUFTbUQ7WUFDWDtRQUNGO1FBQ0FGLFVBQVU7SUFDWjtJQUNBLE9BQU87UUFDTHRIO1FBQ0FrRjtRQUNBSztRQUNBZ0M7UUFDQUY7UUFDQWpEO0lBQ0Y7QUFDRjtBQUtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktY29tcGFuaW9uLy4vbm9kZV9tb2R1bGVzL2FpL3JlYWN0L2Rpc3QvaW5kZXgubWpzPzJiZmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIHJlYWN0L3VzZS1jaGF0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUiBmcm9tIFwic3dyXCI7XG5cbi8vIHNoYXJlZC91dGlscy50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcblxuLy8gc2hhcmVkL3N0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIxXCIsXG4gIG5hbWU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmdW5jdGlvbl9jYWxsXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fCAhKFwibmFtZVwiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fCB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjJcIixcbiAgbmFtZTogXCJkYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50TWVzc2FnZSA9IHtcbiAgY29kZTogXCI0XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB2YWx1ZSkgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImNvbnRlbnRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmlkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHwgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAoaXRlbSkgPT4gaXRlbSAhPSBudWxsICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGl0ZW0gJiYgaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtICYmIGl0ZW0udGV4dCAhPSBudWxsICYmIHR5cGVvZiBpdGVtLnRleHQgPT09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIGl0ZW0udGV4dCAmJiB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRDb250cm9sRGF0YSA9IHtcbiAgY29kZTogXCI1XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0aHJlYWRJZFwiIGluIHZhbHVlKSB8fCAhKFwibWVzc2FnZUlkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50aHJlYWRJZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUubWVzc2FnZUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRocmVhZElkXCIgYW5kIFwibWVzc2FnZUlkXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZFxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgc3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0LFxuICBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBkYXRhU3RyZWFtUGFydCxcbiAgZXJyb3JTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRNZXNzYWdlLFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVxuXTtcbnZhciBzdHJlYW1QYXJ0c0J5Q29kZSA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0LmNvZGVdOiB0ZXh0U3RyZWFtUGFydCxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIFtkYXRhU3RyZWFtUGFydC5jb2RlXTogZGF0YVN0cmVhbVBhcnQsXG4gIFtlcnJvclN0cmVhbVBhcnQuY29kZV06IGVycm9yU3RyZWFtUGFydCxcbiAgW2Fzc2lzdGFudE1lc3NhZ2UuY29kZV06IGFzc2lzdGFudE1lc3NhZ2UsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YS5jb2RlXTogYXNzaXN0YW50Q29udHJvbERhdGFcbn07XG52YXIgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5uYW1lXTogdGV4dFN0cmVhbVBhcnQuY29kZSxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQubmFtZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2UubmFtZV06IGFzc2lzdGFudE1lc3NhZ2UuY29kZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhLm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YS5jb2RlXG59O1xudmFyIHZhbGlkQ29kZXMgPSBzdHJlYW1QYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQuY29kZSk7XG52YXIgcGFyc2VTdHJlYW1QYXJ0ID0gKGxpbmUpID0+IHtcbiAgY29uc3QgZmlyc3RTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gIGlmIChmaXJzdFNlcGFyYXRvckluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuXCIpO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGxpbmUuc2xpY2UoMCwgZmlyc3RTZXBhcmF0b3JJbmRleCk7XG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gSW52YWxpZCBjb2RlICR7cHJlZml4fS5gKTtcbiAgfVxuICBjb25zdCBjb2RlID0gcHJlZml4O1xuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlID0gSlNPTi5wYXJzZSh0ZXh0VmFsdWUpO1xuICByZXR1cm4gc3RyZWFtUGFydHNCeUNvZGVbY29kZV0ucGFyc2UoanNvblZhbHVlKTtcbn07XG5cbi8vIHNoYXJlZC91dGlscy50c1xudmFyIG5hbm9pZCA9IGN1c3RvbUFscGhhYmV0KFxuICBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsXG4gIDdcbik7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoY29tcGxleCkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGlmICghY29tcGxleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgaWYgKCFjaHVuaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpO1xuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cbnZhciBDT01QTEVYX0hFQURFUiA9IFwiWC1FeHBlcmltZW50YWwtU3RyZWFtLURhdGFcIjtcblxuLy8gc2hhcmVkL2NhbGwtYXBpLnRzXG5pbXBvcnQgeyBuYW5vaWQgYXMgbmFub2lkMiB9IGZyb20gXCJuYW5vaWRcIjtcblxuLy8gc2hhcmVkL3BhcnNlLWNvbXBsZXgtcmVzcG9uc2UudHNcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgcmVhZGVyLFxuICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gIHVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQgPSBuYW5vaWQsXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbn0pIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gZ2V0Q3VycmVudERhdGUoKTtcbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKHRydWUpO1xuICBjb25zdCBwcmVmaXhNYXAgPSB7XG4gICAgZGF0YTogW11cbiAgfTtcbiAgY29uc3QgTkVXTElORSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IGxpbmVzID0gZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcyk7XG4gICAgaWYgKHR5cGVvZiBsaW5lcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0LiBDb21wbGV4IG1vZGUgd2FzIHNldCBidXQgdGhlIHJlc3BvbnNlIGlzIGEgc3RyaW5nLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyB0eXBlLCB2YWx1ZTogdmFsdWUyIH0gb2YgbGluZXMpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInRleHRcIikge1xuICAgICAgICBpZiAocHJlZml4TWFwW1widGV4dFwiXSkge1xuICAgICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgICAuLi5wcmVmaXhNYXBbXCJ0ZXh0XCJdLFxuICAgICAgICAgICAgY29udGVudDogKHByZWZpeE1hcFtcInRleHRcIl0uY29udGVudCB8fCBcIlwiKSArIHZhbHVlMlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgY29udGVudDogdmFsdWUyLFxuICAgICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25fY2FsbFwiKSB7XG4gICAgICAgIHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl0gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgZnVuY3Rpb25fY2FsbDogdmFsdWUyLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgbmFtZTogdmFsdWUyLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl07XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXS5wdXNoKC4uLnZhbHVlMik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJ0ZXh0XCJdO1xuICAgICAgY29uc3QgbWVyZ2VkID0gW2Z1bmN0aW9uQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV0uZmlsdGVyKFxuICAgICAgICBCb29sZWFuXG4gICAgICApO1xuICAgICAgdXBkYXRlKG1lcmdlZCwgWy4uLnByZWZpeE1hcFtcImRhdGFcIl1dKTtcbiAgICAgIGlmICgoYWJvcnRDb250cm9sbGVyUmVmID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkgPT09IG51bGwpIHtcbiAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHByZWZpeE1hcCk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtwcmVmaXhNYXAudGV4dCwgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGxdLmZpbHRlcihcbiAgICAgIEJvb2xlYW5cbiAgICApLFxuICAgIGRhdGE6IHByZWZpeE1hcC5kYXRhXG4gIH07XG59XG5cbi8vIHNoYXJlZC9jYWxsLWFwaS50c1xuYXN5bmMgZnVuY3Rpb24gY2FsbEFwaSh7XG4gIGFwaSxcbiAgbWVzc2FnZXMsXG4gIGJvZHksXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIGFwcGVuZE1lc3NhZ2UsXG4gIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSxcbiAgb25SZXNwb25zZSxcbiAgb25VcGRhdGUsXG4gIG9uRmluaXNoXG59KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgLi4uYm9keVxuICAgIH0pLFxuICAgIGhlYWRlcnMsXG4gICAgc2lnbmFsOiAoX2EgPSBhYm9ydENvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzXG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuICBpZiAob25SZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGF3YWl0IHJlc3BvbnNlLnRleHQoKSB8fCBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGlzQ29tcGxleE1vZGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChDT01QTEVYX0hFQURFUikgPT09IFwidHJ1ZVwiO1xuICBpZiAoaXNDb21wbGV4TW9kZSkge1xuICAgIHJldHVybiBhd2FpdCBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gICAgICByZWFkZXIsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWY6IGFib3J0Q29udHJvbGxlciAhPSBudWxsID8geyBjdXJyZW50OiBhYm9ydENvbnRyb2xsZXIoKSB9IDogdm9pZCAwLFxuICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgIG9uRmluaXNoKHByZWZpeE1hcCkge1xuICAgICAgICBpZiAob25GaW5pc2ggJiYgcHJlZml4TWFwLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIG9uRmluaXNoKHByZWZpeE1hcC50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcihmYWxzZSk7XG4gICAgbGV0IHN0cmVhbWVkUmVzcG9uc2UgPSBcIlwiO1xuICAgIGNvbnN0IHJlcGx5SWQgPSBuYW5vaWQyKCk7XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHtcbiAgICAgIGlkOiByZXBseUlkLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgY29udGVudDogXCJcIixcbiAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCJcbiAgICB9O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdHJlYW1lZFJlc3BvbnNlICs9IGRlY29kZSh2YWx1ZSk7XG4gICAgICBpZiAoc3RyZWFtZWRSZXNwb25zZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykpIHtcbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHN0cmVhbWVkUmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZU1lc3NhZ2VbXCJjb250ZW50XCJdID0gc3RyZWFtZWRSZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIGFwcGVuZE1lc3NhZ2UoeyAuLi5yZXNwb25zZU1lc3NhZ2UgfSk7XG4gICAgICBpZiAoKGFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyKCkpID09PSBudWxsKSB7XG4gICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJlYW1lZFJlc3BvbnNlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSkge1xuICAgICAgY29uc3QgcGFyc2VkRnVuY3Rpb25DYWxsID0gSlNPTi5wYXJzZShzdHJlYW1lZFJlc3BvbnNlKS5mdW5jdGlvbl9jYWxsO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHBhcnNlZEZ1bmN0aW9uQ2FsbDtcbiAgICAgIGFwcGVuZE1lc3NhZ2UoeyAuLi5yZXNwb25zZU1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxufVxuXG4vLyBzaGFyZWQvcHJvY2Vzcy1jaGF0LXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlOiBnZXRTdHJlYW1lZFJlc3BvbnNlMixcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICB1cGRhdGVDaGF0UmVxdWVzdCxcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzXG59KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSA9IGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UyKCk7XG4gICAgaWYgKFwibWVzc2FnZXNcIiBpbiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlKSB7XG4gICAgICBsZXQgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCB8fCB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzKCksXG4gICAgICAgICAgICBmdW5jdGlvbkNhbGxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNGb2xsb3dpbmdSZXNwb25zZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlO1xuICAgICAgaWYgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCB8fCB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIGZ1bmN0aW9uQ2FsbCk7XG4gICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdChmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlYWN0L3VzZS1jaGF0LnRzXG52YXIgZ2V0U3RyZWFtZWRSZXNwb25zZSA9IGFzeW5jIChhcGksIGNoYXRSZXF1ZXN0LCBtdXRhdGUsIG11dGF0ZVN0cmVhbURhdGEsIGV4aXN0aW5nRGF0YSwgZXh0cmFNZXRhZGF0YVJlZiwgbWVzc2FnZXNSZWYsIGFib3J0Q29udHJvbGxlclJlZiwgb25GaW5pc2gsIG9uUmVzcG9uc2UsIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcHJldmlvdXNNZXNzYWdlcyA9IG1lc3NhZ2VzUmVmLmN1cnJlbnQ7XG4gIG11dGF0ZShjaGF0UmVxdWVzdC5tZXNzYWdlcywgZmFsc2UpO1xuICBjb25zdCBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCA9IHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMgPyBjaGF0UmVxdWVzdC5tZXNzYWdlcyA6IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLm1hcCgoeyByb2xlLCBjb250ZW50LCBuYW1lLCBmdW5jdGlvbl9jYWxsIH0pID0+ICh7XG4gICAgcm9sZSxcbiAgICBjb250ZW50LFxuICAgIC4uLm5hbWUgIT09IHZvaWQgMCAmJiB7IG5hbWUgfSxcbiAgICAuLi5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYge1xuICAgICAgZnVuY3Rpb25fY2FsbFxuICAgIH1cbiAgfSkpO1xuICBpZiAodHlwZW9mIGFwaSAhPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHJlcGx5SWQgPSBuYW5vaWQoKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgaWQ6IHJlcGx5SWQsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIlxuICAgIH07XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZFJvdyhwcm9taXNlKSB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIHVpLCBuZXh0IH0gPSBhd2FpdCBwcm9taXNlO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlW1wiY29udGVudFwiXSA9IGNvbnRlbnQ7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJ1aVwiXSA9IGF3YWl0IHVpO1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgeyAuLi5yZXNwb25zZU1lc3NhZ2UgfV0sIGZhbHNlKTtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGF3YWl0IHJlYWRSb3cobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gYXBpKHtcbiAgICAgICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkLFxuICAgICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHJlYWRSb3cocHJvbWlzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxuICByZXR1cm4gYXdhaXQgY2FsbEFwaSh7XG4gICAgYXBpLFxuICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCxcbiAgICBib2R5OiB7XG4gICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmJvZHksXG4gICAgICAuLi4oX2EgPSBjaGF0UmVxdWVzdC5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYm9keSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgZnVuY3Rpb25zOiBjaGF0UmVxdWVzdC5mdW5jdGlvbnNcbiAgICAgIH0sXG4gICAgICAuLi5jaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYge1xuICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLFxuICAgICAgLi4uKF9iID0gY2hhdFJlcXVlc3Qub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhlYWRlcnNcbiAgICB9LFxuICAgIGFib3J0Q29udHJvbGxlcjogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQsXG4gICAgYXBwZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBtZXNzYWdlXSwgZmFsc2UpO1xuICAgIH0sXG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25VcGRhdGUobWVyZ2VkLCBkYXRhKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCAuLi5tZXJnZWRdLCBmYWxzZSk7XG4gICAgICBtdXRhdGVTdHJlYW1EYXRhKFsuLi5leGlzdGluZ0RhdGEgfHwgW10sIC4uLmRhdGEgfHwgW11dLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvbkZpbmlzaFxuICB9KTtcbn07XG5mdW5jdGlvbiB1c2VDaGF0KHtcbiAgYXBpID0gXCIvYXBpL2NoYXRcIixcbiAgaWQsXG4gIGluaXRpYWxNZXNzYWdlcyxcbiAgaW5pdGlhbElucHV0ID0gXCJcIixcbiAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHlcbn0gPSB7fSkge1xuICBjb25zdCBob29rSWQgPSB1c2VJZCgpO1xuICBjb25zdCBjaGF0SWQgPSBpZCB8fCBob29rSWQ7XG4gIGNvbnN0IFtpbml0aWFsTWVzc2FnZXNGYWxsYmFja10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHsgZGF0YTogbWVzc2FnZXMsIG11dGF0ZSB9ID0gdXNlU1dSKFthcGksIGNoYXRJZF0sIG51bGwsIHtcbiAgICBmYWxsYmFja0RhdGE6IGluaXRpYWxNZXNzYWdlcyAhPSBudWxsID8gaW5pdGlhbE1lc3NhZ2VzIDogaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2tcbiAgfSk7XG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSKFxuICAgIFtjaGF0SWQsIFwibG9hZGluZ1wiXSxcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IHsgZGF0YTogc3RyZWFtRGF0YSwgbXV0YXRlOiBtdXRhdGVTdHJlYW1EYXRhIH0gPSB1c2VTV1IoW2NoYXRJZCwgXCJzdHJlYW1EYXRhXCJdLCBudWxsKTtcbiAgY29uc3QgbWVzc2FnZXNSZWYgPSB1c2VSZWYobWVzc2FnZXMgfHwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlcyB8fCBbXTtcbiAgfSwgW21lc3NhZ2VzXSk7XG4gIGNvbnN0IGFib3J0Q29udHJvbGxlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZSgpO1xuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjaGF0UmVxdWVzdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICAgICAgICAgIGdldFN0cmVhbWVkUmVzcG9uc2U6ICgpID0+IGdldFN0cmVhbWVkUmVzcG9uc2UoXG4gICAgICAgICAgICBhcGksXG4gICAgICAgICAgICBjaGF0UmVxdWVzdCxcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICAgICAgICBzdHJlYW1EYXRhLFxuICAgICAgICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgICAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgICAgICAgb25GaW5pc2gsXG4gICAgICAgICAgICBvblJlc3BvbnNlLFxuICAgICAgICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkc1xuICAgICAgICAgICksXG4gICAgICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0OiAoY2hhdFJlcXVlc3RQYXJhbSkgPT4ge1xuICAgICAgICAgICAgY2hhdFJlcXVlc3QgPSBjaGF0UmVxdWVzdFBhcmFtO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzOiAoKSA9PiBtZXNzYWdlc1JlZi5jdXJyZW50XG4gICAgICAgIH0pO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRFcnJvcihlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICBzdHJlYW1EYXRhLFxuICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudFxuICAgIF1cbiAgKTtcbiAgY29uc3QgYXBwZW5kID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKG1lc3NhZ2UsIHsgb3B0aW9ucywgZnVuY3Rpb25zLCBmdW5jdGlvbl9jYWxsLCBkYXRhIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKCFtZXNzYWdlLmlkKSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBuYW5vaWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5jb25jYXQobWVzc2FnZSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIC4uLmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25zIH0sXG4gICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdXG4gICk7XG4gIGNvbnN0IHJlbG9hZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh7IG9wdGlvbnMsIGZ1bmN0aW9ucywgZnVuY3Rpb25fY2FsbCB9ID0ge30pID0+IHtcbiAgICAgIGlmIChtZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzUmVmLmN1cnJlbnRbbWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0TWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiKSB7XG4gICAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0MiA9IHtcbiAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5zbGljZSgwLCAtMSksXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAuLi5mdW5jdGlvbnMgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9ucyB9LFxuICAgICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LmFib3J0KCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHNldE1lc3NhZ2VzID0gdXNlQ2FsbGJhY2soXG4gICAgKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgbXV0YXRlKG1lc3NhZ2VzMiwgZmFsc2UpO1xuICAgICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzMjtcbiAgICB9LFxuICAgIFttdXRhdGVdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoaW5pdGlhbElucHV0KTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKGUsIG9wdGlvbnMgPSB7fSwgbWV0YWRhdGEpID0+IHtcbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgIC4uLm1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KVxuICAgICAgICByZXR1cm47XG4gICAgICBhcHBlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBjb250ZW50OiBpbnB1dCxcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjcmVhdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgICBzZXRJbnB1dChcIlwiKTtcbiAgICB9LFxuICAgIFtpbnB1dCwgYXBwZW5kXVxuICApO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlKSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCBbXSxcbiAgICBlcnJvcixcbiAgICBhcHBlbmQsXG4gICAgcmVsb2FkLFxuICAgIHN0b3AsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhXG4gIH07XG59XG5cbi8vIHJlYWN0L3VzZS1jb21wbGV0aW9uLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VJZCBhcyB1c2VJZDIsIHVzZVJlZiBhcyB1c2VSZWYyLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB1c2VTV1IyIGZyb20gXCJzd3JcIjtcbmZ1bmN0aW9uIHVzZUNvbXBsZXRpb24oe1xuICBhcGkgPSBcIi9hcGkvY29tcGxldGlvblwiLFxuICBpZCxcbiAgaW5pdGlhbENvbXBsZXRpb24gPSBcIlwiLFxuICBpbml0aWFsSW5wdXQgPSBcIlwiLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3Jcbn0gPSB7fSkge1xuICBjb25zdCBob29rSWQgPSB1c2VJZDIoKTtcbiAgY29uc3QgY29tcGxldGlvbklkID0gaWQgfHwgaG9va0lkO1xuICBjb25zdCB7IGRhdGEsIG11dGF0ZSB9ID0gdXNlU1dSMihbYXBpLCBjb21wbGV0aW9uSWRdLCBudWxsLCB7XG4gICAgZmFsbGJhY2tEYXRhOiBpbml0aWFsQ29tcGxldGlvblxuICB9KTtcbiAgY29uc3QgeyBkYXRhOiBpc0xvYWRpbmcgPSBmYWxzZSwgbXV0YXRlOiBtdXRhdGVMb2FkaW5nIH0gPSB1c2VTV1IyKFxuICAgIFtjb21wbGV0aW9uSWQsIFwibG9hZGluZ1wiXSxcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUyKHZvaWQgMCk7XG4gIGNvbnN0IGNvbXBsZXRpb24gPSBkYXRhO1xuICBjb25zdCBbYWJvcnRDb250cm9sbGVyLCBzZXRBYm9ydENvbnRyb2xsZXJdID0gdXNlU3RhdGUyKG51bGwpO1xuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmMih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5XG4gIH0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jIChwcm9tcHQsIG9wdGlvbnMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlcjIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHNldEFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIyKTtcbiAgICAgICAgbXV0YXRlKFwiXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyMi5zaWduYWxcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBhd2FpdCByZXMudGV4dCgpIHx8IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgKz0gZGVjb2Rlcih2YWx1ZSk7XG4gICAgICAgICAgbXV0YXRlKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldEVycm9yKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yXG4gICAgXVxuICApO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2syKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICB9XG4gIH0sIFthYm9ydENvbnRyb2xsZXJdKTtcbiAgY29uc3Qgc2V0Q29tcGxldGlvbiA9IHVzZUNhbGxiYWNrMihcbiAgICAoY29tcGxldGlvbjIpID0+IHtcbiAgICAgIG11dGF0ZShjb21wbGV0aW9uMiwgZmFsc2UpO1xuICAgIH0sXG4gICAgW211dGF0ZV1cbiAgKTtcbiAgY29uc3QgY29tcGxldGUgPSB1c2VDYWxsYmFjazIoXG4gICAgYXN5bmMgKHByb21wdCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KHByb21wdCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUyKGluaXRpYWxJbnB1dCk7XG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrMihcbiAgICAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlKGlucHV0KTtcbiAgICB9LFxuICAgIFtpbnB1dCwgY29tcGxldGVdXG4gICk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGUpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgY29tcGxldGlvbixcbiAgICBjb21wbGV0ZSxcbiAgICBlcnJvcixcbiAgICBzZXRDb21wbGV0aW9uLFxuICAgIHN0b3AsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZ1xuICB9O1xufVxuXG4vLyByZWFjdC91c2UtYXNzaXN0YW50LnRzXG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTMgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc2hhcmVkL3Byb2Nlc3MtbWVzc2FnZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlU3RyZWFtKHJlYWRlciwgcHJvY2Vzc01lc3NhZ2UpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHJvY2Vzc01lc3NhZ2UoYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIGxldCBlbmRJbmRleDtcbiAgICB3aGlsZSAoKGVuZEluZGV4ID0gYnVmZmVyLmluZGV4T2YoXCJcXG5cIikpICE9PSAtMSkge1xuICAgICAgcHJvY2Vzc01lc3NhZ2UoYnVmZmVyLnN1YnN0cmluZygwLCBlbmRJbmRleCkudHJpbSgpKTtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHJpbmcoZW5kSW5kZXggKyAxKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcmVhY3QvdXNlLWFzc2lzdGFudC50c1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCh7XG4gIGFwaSxcbiAgdGhyZWFkSWQ6IHRocmVhZElkUGFyYW1cbn0pIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTMoW10pO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlMyhcIlwiKTtcbiAgY29uc3QgW3RocmVhZElkLCBzZXRUaHJlYWRJZF0gPSB1c2VTdGF0ZTModm9pZCAwKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlMyhcImF3YWl0aW5nX21lc3NhZ2VcIik7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUzKHZvaWQgMCk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGUpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG4gIGNvbnN0IHN1Ym1pdE1lc3NhZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGlucHV0ID09PSBcIlwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFN0YXR1cyhcImluX3Byb2dyZXNzXCIpO1xuICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IFtcbiAgICAgIC4uLm1lc3NhZ2VzMixcbiAgICAgIHsgaWQ6IFwiXCIsIHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBpbnB1dCB9XG4gICAgXSk7XG4gICAgc2V0SW5wdXQoXCJcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAvLyBhbHdheXMgdXNlIHVzZXItcHJvdmlkZWQgdGhyZWFkSWQgd2hlbiBhdmFpbGFibGU6XG4gICAgICAgIHRocmVhZElkOiAoX2EgPSB0aHJlYWRJZFBhcmFtICE9IG51bGwgPyB0aHJlYWRJZFBhcmFtIDogdGhyZWFkSWQpICE9IG51bGwgPyBfYSA6IG51bGwsXG4gICAgICAgIG1lc3NhZ2U6IGlucHV0XG4gICAgICB9KVxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGF3YWl0IHByb2Nlc3NNZXNzYWdlU3RyZWFtKHJlc3VsdC5ib2R5LmdldFJlYWRlcigpLCAobWVzc2FnZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gcGFyc2VTdHJlYW1QYXJ0KG1lc3NhZ2UpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYXNzaXN0YW50X21lc3NhZ2VcIjoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlczIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgcm9sZTogdmFsdWUucm9sZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50WzBdLnRleHQudmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIjoge1xuICAgICAgICAgICAgc2V0VGhyZWFkSWQodmFsdWUudGhyZWFkSWQpO1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzMlttZXNzYWdlczIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmlkID0gdmFsdWUubWVzc2FnZUlkO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLm1lc3NhZ2VzMi5zbGljZSgwLCBtZXNzYWdlczIubGVuZ3RoIC0gMSksIGxhc3RNZXNzYWdlXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICBzZXRFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBzZXRFcnJvcihlcnJvcjIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNldFN0YXR1cyhcImF3YWl0aW5nX21lc3NhZ2VcIik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgc3VibWl0TWVzc2FnZSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3JcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQsXG4gIHVzZUNoYXQsXG4gIHVzZUNvbXBsZXRpb25cbn07XG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU1dSIiwiY3VzdG9tQWxwaGFiZXQiLCJ0ZXh0U3RyZWFtUGFydCIsImNvZGUiLCJuYW1lIiwicGFyc2UiLCJ2YWx1ZSIsIkVycm9yIiwidHlwZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlIiwiaWQiLCJyb2xlIiwiY29udGVudCIsImV2ZXJ5IiwiaXRlbSIsInRleHQiLCJhc3Npc3RhbnRDb250cm9sRGF0YSIsInRocmVhZElkIiwibWVzc2FnZUlkIiwic3RyZWFtUGFydHMiLCJzdHJlYW1QYXJ0c0J5Q29kZSIsIlN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlcyIsIm1hcCIsInBhcnQiLCJwYXJzZVN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJzbGljZSIsImluY2x1ZGVzIiwidGV4dFZhbHVlIiwianNvblZhbHVlIiwiSlNPTiIsIm5hbm9pZCIsImNyZWF0ZUNodW5rRGVjb2RlciIsImNvbXBsZXgiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJjaHVuayIsImRlY29kZSIsInN0cmVhbSIsImRlY29kZWQiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJDT01QTEVYX0hFQURFUiIsIm5hbm9pZDIiLCJwYXJzZUNvbXBsZXhSZXNwb25zZSIsInJlYWRlciIsImFib3J0Q29udHJvbGxlclJlZiIsInVwZGF0ZSIsIm9uRmluaXNoIiwiZ2VuZXJhdGVJZCIsImdldEN1cnJlbnREYXRlIiwiRGF0ZSIsImNyZWF0ZWRBdCIsInByZWZpeE1hcCIsImRhdGEiLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwicmVhZCIsInB1c2giLCJsZW5ndGgiLCJjb25jYXRlbmF0ZWRDaHVua3MiLCJVaW50OEFycmF5Iiwib2Zmc2V0Iiwic2V0IiwibGluZXMiLCJ2YWx1ZTIiLCJmdW5jdGlvbkNhbGxNZXNzYWdlIiwicmVzcG9uc2VNZXNzYWdlIiwibWVyZ2VkIiwiY3VycmVudCIsImNhbmNlbCIsIm1lc3NhZ2VzIiwiY2FsbEFwaSIsImFwaSIsImJvZHkiLCJjcmVkZW50aWFscyIsImhlYWRlcnMiLCJhYm9ydENvbnRyb2xsZXIiLCJhcHBlbmRNZXNzYWdlIiwicmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlIiwib25SZXNwb25zZSIsIm9uVXBkYXRlIiwiX2EiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwic3RyaW5naWZ5Iiwic2lnbmFsIiwiY2F0Y2giLCJlcnIiLCJvayIsImdldFJlYWRlciIsImlzQ29tcGxleE1vZGUiLCJnZXQiLCJzdHJlYW1lZFJlc3BvbnNlIiwicmVwbHlJZCIsImRvbmUiLCJzdGFydHNXaXRoIiwicGFyc2VkRnVuY3Rpb25DYWxsIiwicHJvY2Vzc0NoYXRTdHJlYW0iLCJnZXRTdHJlYW1lZFJlc3BvbnNlIiwiZ2V0U3RyZWFtZWRSZXNwb25zZTIiLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJ1cGRhdGVDaGF0UmVxdWVzdCIsImdldEN1cnJlbnRNZXNzYWdlcyIsIm1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UiLCJoYXNGb2xsb3dpbmdSZXNwb25zZSIsIm1lc3NhZ2UiLCJmdW5jdGlvbkNhbGwiLCJmdW5jdGlvbkNhbGxSZXNwb25zZSIsInN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlIiwiY2hhdFJlcXVlc3QiLCJtdXRhdGUiLCJtdXRhdGVTdHJlYW1EYXRhIiwiZXhpc3RpbmdEYXRhIiwiZXh0cmFNZXRhZGF0YVJlZiIsIm1lc3NhZ2VzUmVmIiwic2VuZEV4dHJhTWVzc2FnZUZpZWxkcyIsIl9iIiwicHJldmlvdXNNZXNzYWdlcyIsImNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkIiwicmVhZFJvdyIsInByb21pc2UiLCJ1aSIsIm5leHQiLCJlIiwib3B0aW9ucyIsImZ1bmN0aW9ucyIsInVzZUNoYXQiLCJpbml0aWFsTWVzc2FnZXMiLCJpbml0aWFsSW5wdXQiLCJvbkVycm9yIiwiaG9va0lkIiwiY2hhdElkIiwiaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2siLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmlnZ2VyUmVxdWVzdCIsIkFib3J0Q29udHJvbGxlciIsImNoYXRSZXF1ZXN0UGFyYW0iLCJhcHBlbmQiLCJjb25jYXQiLCJyZWxvYWQiLCJsYXN0TWVzc2FnZSIsImNoYXRSZXF1ZXN0MiIsInN0b3AiLCJhYm9ydCIsInNldE1lc3NhZ2VzIiwibWVzc2FnZXMyIiwiaW5wdXQiLCJzZXRJbnB1dCIsImhhbmRsZVN1Ym1pdCIsIm1ldGFkYXRhIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVJbnB1dENoYW5nZSIsInRhcmdldCIsInVzZUNhbGxiYWNrMiIsInVzZUVmZmVjdDIiLCJ1c2VJZDIiLCJ1c2VSZWYyIiwidXNlU3RhdGUyIiwidXNlU1dSMiIsInVzZUNvbXBsZXRpb24iLCJpbml0aWFsQ29tcGxldGlvbiIsImNvbXBsZXRpb25JZCIsImNvbXBsZXRpb24iLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJwcm9tcHQiLCJhYm9ydENvbnRyb2xsZXIyIiwicmVzIiwicmVzdWx0Iiwic2V0Q29tcGxldGlvbiIsImNvbXBsZXRpb24yIiwiY29tcGxldGUiLCJ1c2VTdGF0ZTMiLCJwcm9jZXNzTWVzc2FnZVN0cmVhbSIsInByb2Nlc3NNZXNzYWdlIiwiYnVmZmVyIiwiZW5kSW5kZXgiLCJzdWJzdHJpbmciLCJ0cmltIiwiZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCIsInRocmVhZElkUGFyYW0iLCJzZXRUaHJlYWRJZCIsInN0YXR1cyIsInNldFN0YXR1cyIsInN1Ym1pdE1lc3NhZ2UiLCJlcnJvcjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   COMPLEX_HEADER: () => (/* binding */ COMPLEX_HEADER),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createChunkDecoder: () => (/* binding */ createChunkDecoder),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_StreamingReactResponse: () => (/* binding */ experimental_StreamingReactResponse),\n/* harmony export */   isStreamStringEqualToType: () => (/* binding */ isStreamStringEqualToType),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/nanoid/non-secure/index.js\");\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    async start(controller) {\n      eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_0__.createParser)(\n        (event) => {\n          if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n          // @see https://replicate.com/docs/streaming\n          event.event === \"done\") {\n            controller.terminate();\n            return;\n          }\n          if (\"data\" in event) {\n            const parsedMessage = customParser ? customParser(event.data) : event.data;\n            if (parsedMessage)\n              controller.enqueue(parsedMessage);\n          }\n        }\n      );\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(cb) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const callbacks = cb || {};\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      controller.enqueue(textEncoder.encode(message));\n      aggregatedResponse += message;\n      if (callbacks.onToken)\n        await callbacks.onToken(message);\n    },\n    async flush() {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n  return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\nfunction readableFromAsyncIterable(iterable) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done)\n        controller.close();\n      else\n        controller.enqueue(value);\n    },\n    async cancel(reason) {\n      var _a;\n      await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n    }\n  });\n}\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar functionCallStreamPart = {\n  code: \"1\",\n  name: \"function_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n      throw new Error(\n        '\"function_call\" parts expect an object with a \"function_call\" property.'\n      );\n    }\n    return {\n      type: \"function_call\",\n      value\n    };\n  }\n};\nvar dataStreamPart = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n    return { type: \"data\", value };\n  }\n};\nvar errorStreamPart = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar assistantMessage = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every(\n      (item) => item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\"\n    )) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.'\n      );\n    }\n    return {\n      type: \"assistant_message\",\n      value\n    };\n  }\n};\nvar assistantControlData = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.'\n      );\n    }\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar streamParts = [\n  textStreamPart,\n  functionCallStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  assistantMessage,\n  assistantControlData\n];\nvar streamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [functionCallStreamPart.code]: functionCallStreamPart,\n  [dataStreamPart.code]: dataStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessage.code]: assistantMessage,\n  [assistantControlData.code]: assistantControlData\n};\nvar StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [functionCallStreamPart.name]: functionCallStreamPart.code,\n  [dataStreamPart.name]: dataStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessage.name]: assistantMessage.code,\n  [assistantControlData.name]: assistantControlData.code\n};\nvar validCodes = streamParts.map((part) => part.code);\nvar parseStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n  const streamPart = streamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// shared/utils.ts\n\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_1__.customAlphabet)(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7\n);\nfunction createChunkDecoder(complex) {\n  const decoder = new TextDecoder();\n  if (!complex) {\n    return function(chunk) {\n      if (!chunk)\n        return \"\";\n      return decoder.decode(chunk, { stream: true });\n    };\n  }\n  return function(chunk) {\n    const decoded = decoder.decode(chunk, { stream: true }).split(\"\\n\").filter((line) => line !== \"\");\n    return decoded.map(parseStreamPart).filter(Boolean);\n  };\n}\nvar isStreamStringEqualToType = (type, value) => value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith(\"\\n\");\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n\n// streams/stream-data.ts\nvar experimental_StreamData = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    // closing the stream is synchronous, but we want to return a promise\n    // in case we're doing async work\n    this.isClosedPromise = null;\n    this.isClosedPromiseResolver = void 0;\n    this.isClosed = false;\n    // array to store appended data\n    this.data = [];\n    this.isClosedPromise = new Promise((resolve) => {\n      this.isClosedPromiseResolver = resolve;\n    });\n    const self = this;\n    this.stream = new TransformStream({\n      start: async (controller) => {\n        self.controller = controller;\n      },\n      transform: async (chunk, controller) => {\n        if (self.data.length > 0) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"data\", self.data)\n          );\n          self.data = [];\n          controller.enqueue(encodedData);\n        }\n        controller.enqueue(chunk);\n      },\n      async flush(controller) {\n        const warningTimeout =  true ? setTimeout(() => {\n          console.warn(\n            \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n          );\n        }, 3e3) : 0;\n        await self.isClosedPromise;\n        if (warningTimeout !== null) {\n          clearTimeout(warningTimeout);\n        }\n        if (self.data.length) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"data\", self.data)\n          );\n          controller.enqueue(encodedData);\n        }\n      }\n    });\n  }\n  async close() {\n    var _a;\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    (_a = this.isClosedPromiseResolver) == null ? void 0 : _a.call(this);\n    this.isClosed = true;\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    this.data.push(value);\n  }\n};\nfunction createStreamDataTransformer(experimental_streamData) {\n  if (!experimental_streamData) {\n    return new TransformStream({\n      transform: async (chunk, controller) => {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n    }\n  });\n}\n\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n  const extract = chunkToText();\n  return (data) => {\n    return extract(JSON.parse(data));\n  };\n}\nasync function* streamable(stream) {\n  const extract = chunkToText();\n  for await (const chunk of stream) {\n    const text = extract(chunk);\n    if (text)\n      yield text;\n  }\n}\nfunction chunkToText() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (json) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    if (isChatCompletionChunk(json) && ((_c = (_b = (_a = json.choices[0]) == null ? void 0 : _a.delta) == null ? void 0 : _b.function_call) == null ? void 0 : _c.name)) {\n      isFunctionStreamingIn = true;\n      return `{\"function_call\": {\"name\": \"${(_e = (_d = json.choices[0]) == null ? void 0 : _d.delta) == null ? void 0 : _e.function_call.name}\", \"arguments\": \"`;\n    } else if (isChatCompletionChunk(json) && ((_h = (_g = (_f = json.choices[0]) == null ? void 0 : _f.delta) == null ? void 0 : _g.function_call) == null ? void 0 : _h.arguments)) {\n      const argumentChunk = json.choices[0].delta.function_call.arguments;\n      let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n      return `${escapedPartialJson}`;\n    } else if (isFunctionStreamingIn && (((_i = json.choices[0]) == null ? void 0 : _i.finish_reason) === \"function_call\" || ((_j = json.choices[0]) == null ? void 0 : _j.finish_reason) === \"stop\")) {\n      isFunctionStreamingIn = false;\n      return '\"}}';\n    }\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\"\n    );\n    return text;\n  };\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\n  \"internal_openai_fn_messages\"\n);\nfunction isChatCompletionChunk(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  let stream;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable(res)).pipeThrough(\n      createCallbacksTransformer(\n        (cb == null ? void 0 : cb.experimental_onFunctionCall) ? {\n          ...cb,\n          onFinal: void 0\n        } : {\n          ...cb\n        }\n      )\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      (cb == null ? void 0 : cb.experimental_onFunctionCall) ? {\n        ...cb,\n        onFinal: void 0\n      } : {\n        ...cb\n      }\n    );\n  }\n  if (cb && cb.experimental_onFunctionCall) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(\n      createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData)\n    );\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let aggregatedFinalCompletionResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  const isComplexMode = callbacks == null ? void 0 : callbacks.experimental_streamData;\n  const decode = createChunkDecoder();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n      const shouldHandleAsFunction = isFirstChunk && message.startsWith('{\"function_call\":');\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          isComplexMode ? textEncoder.encode(formatStreamPart(\"text\", message)) : chunk\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller) {\n      try {\n        const isEndOfFunction = !isFirstChunk && callbacks.experimental_onFunctionCall && isFunctionStreamingIn;\n        if (isEndOfFunction && callbacks.experimental_onFunctionCall) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          const argumentsPayload = JSON.parse(payload.function_call.arguments);\n          let newFunctionCallMessages = [\n            ...functionCallMessages\n          ];\n          const functionResponse = await callbacks.experimental_onFunctionCall(\n            {\n              name: payload.function_call.name,\n              arguments: argumentsPayload\n            },\n            (result) => {\n              newFunctionCallMessages = [\n                ...functionCallMessages,\n                {\n                  role: \"assistant\",\n                  content: \"\",\n                  function_call: payload.function_call\n                },\n                {\n                  role: \"function\",\n                  name: payload.function_call.name,\n                  content: JSON.stringify(result)\n                }\n              ];\n              return newFunctionCallMessages;\n            }\n          );\n          if (!functionResponse) {\n            controller.enqueue(\n              textEncoder.encode(\n                isComplexMode ? formatStreamPart(\n                  \"function_call\",\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse)\n                ) : aggregatedResponse\n              )\n            );\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(\n              isComplexMode ? textEncoder.encode(formatStreamPart(\"text\", functionResponse)) : textEncoder.encode(functionResponse)\n            );\n            return;\n          }\n          const filteredCallbacks = {\n            ...callbacks,\n            onStart: void 0\n          };\n          callbacks.onFinal = void 0;\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          });\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    }\n  });\n}\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init, data) {\n    let processedStream = res;\n    if (data) {\n      processedStream = res.pipeThrough(data.stream);\n    }\n    super(processedStream, {\n      ...init,\n      status: 200,\n      headers: {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        [COMPLEX_HEADER]: data ? \"true\" : \"false\",\n        ...init == null ? void 0 : init.headers\n      }\n    });\n  }\n};\nfunction streamToResponse(res, response, init) {\n  response.writeHead((init == null ? void 0 : init.status) || 200, {\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...init == null ? void 0 : init.headers\n  });\n  const reader = res.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n// streams/huggingface-stream.ts\nfunction createParser2(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a, _b;\n      const { value, done } = await res.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_b = (_a = value.token) == null ? void 0 : _a.text) != null ? _b : \"\");\n      if (!text)\n        return;\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        return;\n      }\n      if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n        return;\n      }\n      controller.enqueue(text);\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser2(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(\n    createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData)\n  );\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n    if (!is_finished) {\n      controller.enqueue(text);\n    }\n  }\n}\nasync function readAndProcessLines(reader, controller) {\n  let segment = \"\";\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    segment += utf8Decoder.decode(chunk, { stream: true });\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || \"\";\n    await processLines(linesArray, controller);\n  }\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n  controller.close();\n}\nfunction createParser3(res) {\n  var _a;\n  const reader = (_a = res.body) == null ? void 0 : _a.getReader();\n  return new ReadableStream({\n    async start(controller) {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n      await readAndProcessLines(reader, controller);\n    }\n  });\n}\nfunction CohereStream(reader, callbacks) {\n  return createParser3(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(\n    createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData)\n  );\n}\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    if (\"error\" in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n    if (!(\"completion\" in json)) {\n      return;\n    }\n    const text = json.completion;\n    if (!previous || text.length > previous.length && text.startsWith(previous)) {\n      const delta = text.slice(previous.length);\n      previous = text;\n      return delta;\n    }\n    return text;\n  };\n}\nasync function* streamable2(stream) {\n  for await (const chunk of stream) {\n    const text = chunk.completion;\n    if (text)\n      yield text;\n  }\n}\nfunction AnthropicStream(res, cb) {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable2(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData)\n    );\n  }\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = async (e, runId) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n  const handleStart = async (runId) => {\n    runs.add(runId);\n  };\n  const handleEnd = async (runId) => {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(\n      createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData)\n    ),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm, _prompts, runId) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain, _inputs, runId) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs, runId) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool, _input, runId) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e, runId) => {\n        await handleError(e, runId);\n      }\n    }\n  };\n}\n\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n  var _a;\n  const url = (_a = res.urls) == null ? void 0 : _a.stream;\n  if (!url) {\n    if (res.error)\n      throw new Error(res.error);\n    else\n      throw new Error(\"Missing stream URL in Replicate response\");\n  }\n  const eventStream = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Accept: \"text/event-stream\",\n      ...options == null ? void 0 : options.headers\n    }\n  });\n  return AIStream(eventStream, void 0, cb).pipeThrough(\n    createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData)\n  );\n}\n\n// shared/parse-complex-response.ts\nasync function parseComplexResponse({\n  reader,\n  abortControllerRef,\n  update,\n  onFinish,\n  generateId = nanoid,\n  getCurrentDate = () => /* @__PURE__ */ new Date()\n}) {\n  const createdAt = getCurrentDate();\n  const decode = createChunkDecoder(true);\n  const prefixMap = {\n    data: []\n  };\n  const NEWLINE = \"\\n\".charCodeAt(0);\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    let concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks) {\n      concatenatedChunks.set(chunk, offset);\n      offset += chunk.length;\n    }\n    chunks.length = 0;\n    totalLength = 0;\n    const lines = decode(concatenatedChunks);\n    if (typeof lines === \"string\") {\n      throw new Error(\n        \"Invalid response format. Complex mode was set but the response is a string. This should never happen.\"\n      );\n    }\n    for (const { type, value: value2 } of lines) {\n      if (type === \"text\") {\n        if (prefixMap[\"text\"]) {\n          prefixMap[\"text\"] = {\n            ...prefixMap[\"text\"],\n            content: (prefixMap[\"text\"].content || \"\") + value2\n          };\n        } else {\n          prefixMap[\"text\"] = {\n            id: generateId(),\n            role: \"assistant\",\n            content: value2,\n            createdAt\n          };\n        }\n      }\n      let functionCallMessage = null;\n      if (type === \"function_call\") {\n        prefixMap[\"function_call\"] = {\n          id: generateId(),\n          role: \"assistant\",\n          content: \"\",\n          function_call: value2.function_call,\n          name: value2.function_call.name,\n          createdAt\n        };\n        functionCallMessage = prefixMap[\"function_call\"];\n      }\n      if (type === \"data\") {\n        prefixMap[\"data\"].push(...value2);\n      }\n      const responseMessage = prefixMap[\"text\"];\n      const merged = [functionCallMessage, responseMessage].filter(\n        Boolean\n      );\n      update(merged, [...prefixMap[\"data\"]]);\n      if ((abortControllerRef == null ? void 0 : abortControllerRef.current) === null) {\n        reader.cancel();\n        break;\n      }\n    }\n  }\n  onFinish == null ? void 0 : onFinish(prefixMap);\n  return {\n    messages: [prefixMap.text, prefixMap.function_call].filter(\n      Boolean\n    ),\n    data: prefixMap.data\n  };\n}\n\n// streams/streaming-react-response.ts\nvar experimental_StreamingReactResponse = class {\n  constructor(res, options) {\n    let resolveFunc = () => {\n    };\n    let next = new Promise((resolve) => {\n      resolveFunc = resolve;\n    });\n    if (options == null ? void 0 : options.data) {\n      const processedStream = res.pipeThrough(\n        options.data.stream\n      );\n      let lastPayload = void 0;\n      parseComplexResponse({\n        reader: processedStream.getReader(),\n        update: (merged, data) => {\n          var _a, _b, _c;\n          const content2 = (_b = (_a = merged[0]) == null ? void 0 : _a.content) != null ? _b : \"\";\n          const ui = ((_c = options == null ? void 0 : options.ui) == null ? void 0 : _c.call(options, { content: content2, data })) || content2;\n          const payload = { ui, content: content2 };\n          const resolvePrevious = resolveFunc;\n          const nextRow = new Promise((resolve) => {\n            resolveFunc = resolve;\n          });\n          resolvePrevious({\n            next: nextRow,\n            ...payload\n          });\n          lastPayload = payload;\n        },\n        onFinish: () => {\n          if (lastPayload !== void 0) {\n            resolveFunc({\n              next: null,\n              ...lastPayload\n            });\n          }\n        }\n      });\n      return next;\n    }\n    let content = \"\";\n    const decode = createChunkDecoder();\n    const reader = res.getReader();\n    async function readChunk() {\n      var _a;\n      const { done, value } = await reader.read();\n      if (!done) {\n        content += decode(value);\n      }\n      const ui = ((_a = options == null ? void 0 : options.ui) == null ? void 0 : _a.call(options, { content })) || content;\n      const payload = {\n        ui,\n        content\n      };\n      const resolvePrevious = resolveFunc;\n      const nextRow = done ? null : new Promise((resolve) => {\n        resolveFunc = resolve;\n      });\n      resolvePrevious({\n        next: nextRow,\n        ...payload\n      });\n      if (done) {\n        return;\n      }\n      await readChunk();\n    }\n    readChunk();\n    return next;\n  }\n};\n\n// streams/assistant-response.ts\nfunction experimental_AssistantResponse({ threadId, messageId }, process2) {\n  const stream = new ReadableStream({\n    async start(controller) {\n      var _a;\n      const textEncoder = new TextEncoder();\n      const sendMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"assistant_message\", message))\n        );\n      };\n      const sendError = (errorMessage) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"error\", errorMessage))\n        );\n      };\n      controller.enqueue(\n        textEncoder.encode(\n          formatStreamPart(\"assistant_control_data\", {\n            threadId,\n            messageId\n          })\n        )\n      );\n      try {\n        await process2({\n          threadId,\n          messageId,\n          sendMessage\n        });\n      } catch (error) {\n        sendError((_a = error.message) != null ? _a : `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {\n    },\n    cancel() {\n    }\n  });\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/plain; charset=utf-8\"\n    }\n  });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUc0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0EsMERBQTBELFVBQVU7QUFDcEU7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IseURBQXlELE1BQU07QUFDL0QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxHQUFHO0FBQ0g7QUF1QkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jb21wYW5pb24vLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanM/ZjM1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHJlYW1zL2FpLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgY3JlYXRlUGFyc2VyXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXJcIjtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSB7XG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBldmVudFNvdXJjZVBhcnNlcjtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyID0gY3JlYXRlUGFyc2VyKFxuICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJldmVudFwiICYmIGV2ZW50LmRhdGEgPT09IFwiW0RPTkVdXCIgfHwgLy8gUmVwbGljYXRlIGRvZXNuJ3Qgc2VuZCBbRE9ORV0gYnV0IGRvZXMgc2VuZCBhICdkb25lJyBldmVudFxuICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZXBsaWNhdGUuY29tL2RvY3Mvc3RyZWFtaW5nXG4gICAgICAgICAgZXZlbnQuZXZlbnQgPT09IFwiZG9uZVwiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBjdXN0b21QYXJzZXIgPyBjdXN0b21QYXJzZXIoZXZlbnQuZGF0YSkgOiBldmVudC5kYXRhO1xuICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UpXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyLmZlZWQodGV4dERlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICBjb25zdCBjYWxsYmFja3MgPSBjYiB8fCB7fTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KVxuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgIH0sXG4gICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUobWVzc2FnZSkpO1xuICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICBjb25zdCBpc09wZW5BSUNhbGxiYWNrcyA9IGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcyk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgIWlzT3BlbkFJQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuICByZXR1cm4gXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGxcIiBpbiBjYWxsYmFja3M7XG59XG5mdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuICByZXR1cm4gKHRleHQpID0+IHtcbiAgICBpZiAoaXNTdHJlYW1TdGFydCkge1xuICAgICAgdGV4dCA9IHRleHQudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgaXNTdHJlYW1TdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFJU3RyZWFtKHJlc3BvbnNlLCBjdXN0b21QYXJzZXIsIGNhbGxiYWNrcykge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoYFJlc3BvbnNlIGVycm9yOiAke2Vycm9yVGV4dH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihcIlJlc3BvbnNlIGVycm9yOiBObyByZXNwb25zZSBib2R5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3BvbnNlQm9keVN0cmVhbSA9IHJlc3BvbnNlLmJvZHkgfHwgY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpO1xuICByZXR1cm4gcmVzcG9uc2VCb2R5U3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCkge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgbGV0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpXG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICB9LFxuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGF3YWl0ICgoX2EgPSBpdC5yZXR1cm4pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGl0LCByZWFzb24pKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzaGFyZWQvc3RyZWFtLXBhcnRzLnRzXG52YXIgdGV4dFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMFwiLFxuICBuYW1lOiBcInRleHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjFcIixcbiAgbmFtZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZ1bmN0aW9uX2NhbGxcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8ICEoXCJuYW1lXCIgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHwgIShcImFyZ3VtZW50c1wiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMlwiLFxuICBuYW1lOiBcImRhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBlcnJvclN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiM1wiLFxuICBuYW1lOiBcImVycm9yXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRNZXNzYWdlID0ge1xuICBjb2RlOiBcIjRcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJpZFwiIGluIHZhbHVlKSB8fCAhKFwicm9sZVwiIGluIHZhbHVlKSB8fCAhKFwiY29udGVudFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuaWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJhc3Npc3RhbnRcIiB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZS5jb250ZW50KSB8fCAhdmFsdWUuY29udGVudC5ldmVyeShcbiAgICAgIChpdGVtKSA9PiBpdGVtICE9IG51bGwgJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gaXRlbSAmJiBpdGVtLnR5cGUgPT09IFwidGV4dFwiICYmIFwidGV4dFwiIGluIGl0ZW0gJiYgaXRlbS50ZXh0ICE9IG51bGwgJiYgdHlwZW9mIGl0ZW0udGV4dCA9PT0gXCJvYmplY3RcIiAmJiBcInZhbHVlXCIgaW4gaXRlbS50ZXh0ICYmIHR5cGVvZiBpdGVtLnRleHQudmFsdWUgPT09IFwic3RyaW5nXCJcbiAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGFuIFwiaWRcIiwgXCJyb2xlXCIsIGFuZCBcImNvbnRlbnRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGFzc2lzdGFudENvbnRyb2xEYXRhID0ge1xuICBjb2RlOiBcIjVcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRocmVhZElkXCIgaW4gdmFsdWUpIHx8ICEoXCJtZXNzYWdlSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2UsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhXG5dO1xudmFyIHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZS5jb2RlXTogYXNzaXN0YW50TWVzc2FnZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhLmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVxufTtcbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZS5uYW1lXTogYXNzaXN0YW50TWVzc2FnZS5jb2RlLFxuICBbYXNzaXN0YW50Q29udHJvbERhdGEubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhLmNvZGVcbn07XG52YXIgdmFsaWRDb2RlcyA9IHN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5jb2RlKTtcbnZhciBwYXJzZVN0cmVhbVBhcnQgPSAobGluZSkgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC5cIik7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcbiAgaWYgKCF2YWxpZENvZGVzLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBwcmVmaXg7XG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG4gIHJldHVybiBzdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcbmZ1bmN0aW9uIGZvcm1hdFN0cmVhbVBhcnQodHlwZSwgdmFsdWUpIHtcbiAgY29uc3Qgc3RyZWFtUGFydCA9IHN0cmVhbVBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG4gIGlmICghc3RyZWFtUGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJlYW0gcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XG5gO1xufVxuXG4vLyBzaGFyZWQvdXRpbHMudHNcbmltcG9ydCB7IGN1c3RvbUFscGhhYmV0IH0gZnJvbSBcIm5hbm9pZC9ub24tc2VjdXJlXCI7XG52YXIgbmFub2lkID0gY3VzdG9tQWxwaGFiZXQoXG4gIFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgN1xuKTtcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICBpZiAoIWNodW5rKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIik7XG4gICAgcmV0dXJuIGRlY29kZWQubWFwKHBhcnNlU3RyZWFtUGFydCkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xufVxudmFyIGlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUgPSAodHlwZSwgdmFsdWUpID0+IHZhbHVlLnN0YXJ0c1dpdGgoYCR7U3RyZWFtU3RyaW5nUHJlZml4ZXNbdHlwZV19OmApICYmIHZhbHVlLmVuZHNXaXRoKFwiXFxuXCIpO1xudmFyIENPTVBMRVhfSEVBREVSID0gXCJYLUV4cGVyaW1lbnRhbC1TdHJlYW0tRGF0YVwiO1xuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG52YXIgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIHRoaXMuY29udHJvbGxlciA9IG51bGw7XG4gICAgLy8gY2xvc2luZyB0aGUgc3RyZWFtIGlzIHN5bmNocm9ub3VzLCBidXQgd2Ugd2FudCB0byByZXR1cm4gYSBwcm9taXNlXG4gICAgLy8gaW4gY2FzZSB3ZSdyZSBkb2luZyBhc3luYyB3b3JrXG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuaXNDbG9zZWRQcm9taXNlUmVzb2x2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IGZhbHNlO1xuICAgIC8vIGFycmF5IHRvIHN0b3JlIGFwcGVuZGVkIGRhdGFcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZVJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLnN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgc3RhcnQ6IGFzeW5jIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHNlbGYuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgaWYgKHNlbGYuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlZERhdGEgPSBzZWxmLmVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImRhdGFcIiwgc2VsZi5kYXRhKVxuICAgICAgICAgICk7XG4gICAgICAgICAgc2VsZi5kYXRhID0gW107XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgd2FybmluZ1RpbWVvdXQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJUaGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZy4gRGlkIHlvdSBmb3JnZXQgdG8gY2xvc2UgaXQgd2l0aCBgZGF0YS5jbG9zZSgpYD9cIlxuICAgICAgICAgICk7XG4gICAgICAgIH0sIDNlMykgOiBudWxsO1xuICAgICAgICBhd2FpdCBzZWxmLmlzQ2xvc2VkUHJvbWlzZTtcbiAgICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJkYXRhXCIsIHNlbGYuZGF0YSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIChfYSA9IHRoaXMuaXNDbG9zZWRQcm9taXNlUmVzb2x2ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICB9XG4gIGFwcGVuZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihleHBlcmltZW50YWxfc3RyZWFtRGF0YSkge1xuICBpZiAoIWV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIG1lc3NhZ2UpKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzXG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIHJldHVybiBleHRyYWN0KEpTT04ucGFyc2UoZGF0YSkpO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUoc3RyZWFtKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGNvbnN0IHRleHQgPSBleHRyYWN0KGNodW5rKTtcbiAgICBpZiAodGV4dClcbiAgICAgIHlpZWxkIHRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGNodW5rVG9UZXh0KCkge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW47XG4gIHJldHVybiAoanNvbikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfajtcbiAgICBpZiAoaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmICgoX2MgPSAoX2IgPSAoX2EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfYy5uYW1lKSkge1xuICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgIHJldHVybiBge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiJHsoX2UgPSAoX2QgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZC5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgO1xuICAgIH0gZWxzZSBpZiAoaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmICgoX2ggPSAoX2cgPSAoX2YgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZi5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpKSB7XG4gICAgICBjb25zdCBhcmd1bWVudENodW5rID0ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzO1xuICAgICAgbGV0IGVzY2FwZWRQYXJ0aWFsSnNvbiA9IGFyZ3VtZW50Q2h1bmsucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFwvXCIpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9cXGYvZywgXCJcXFxcZlwiKTtcbiAgICAgIHJldHVybiBgJHtlc2NhcGVkUGFydGlhbEpzb259YDtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKChfaSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLmZpbmlzaF9yZWFzb24pID09PSBcImZ1bmN0aW9uX2NhbGxcIiB8fCAoKF9qID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2ouZmluaXNoX3JlYXNvbikgPT09IFwic3RvcFwiKSkge1xuICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICByZXR1cm4gJ1wifX0nO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oXG4gICAgICBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikgJiYganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgPyBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA6IGlzQ29tcGxldGlvbihqc29uKSA/IGpzb24uY2hvaWNlc1swXS50ZXh0IDogXCJcIlxuICAgICk7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG52YXIgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgXCJpbnRlcm5hbF9vcGVuYWlfZm5fbWVzc2FnZXNcIlxuKTtcbmZ1bmN0aW9uIGlzQ2hhdENvbXBsZXRpb25DaHVuayhkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJkZWx0YVwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIGlzQ29tcGxldGlvbihkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJ0ZXh0XCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gT3BlbkFJU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIGNvbnN0IGNiID0gY2FsbGJhY2tzO1xuICBsZXQgc3RyZWFtO1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlKHJlcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gICAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSA/IHtcbiAgICAgICAgICAuLi5jYixcbiAgICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAuLi5jYlxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBBSVN0cmVhbShcbiAgICAgIHJlcyxcbiAgICAgIHBhcnNlT3BlbkFJU3RyZWFtKCksXG4gICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgPyB7XG4gICAgICAgIC4uLmNiLFxuICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLmNiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBpZiAoY2IgJiYgY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IFwiXCI7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gY2FsbGJhY2tzW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdIHx8IFtdO1xuICBjb25zdCBpc0NvbXBsZXhNb2RlID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGE7XG4gIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2RlKGNodW5rKTtcbiAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgY29uc3Qgc2hvdWxkSGFuZGxlQXNGdW5jdGlvbiA9IGlzRmlyc3RDaHVuayAmJiBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKTtcbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Z1bmN0aW9uU3RyZWFtaW5nSW4pIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIGlzQ29tcGxleE1vZGUgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgbWVzc2FnZSkpIDogY2h1bmtcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpc0VuZE9mRnVuY3Rpb24gPSAhaXNGaXJzdENodW5rICYmIGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgJiYgaXNGdW5jdGlvblN0cmVhbWluZ0luO1xuICAgICAgICBpZiAoaXNFbmRPZkZ1bmN0aW9uICYmIGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c1BheWxvYWQgPSBKU09OLnBhcnNlKHBheWxvYWQuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMpO1xuICAgICAgICAgIGxldCBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgXTtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzUGF5bG9hZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFmdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICBpc0NvbXBsZXhNb2RlID8gZm9ybWF0U3RyZWFtUGFydChcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgdG8gcHJldmVudCBkb3VibGUtZW5jb2Rpbmc6XG4gICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSlcbiAgICAgICAgICAgICAgICApIDogYWdncmVnYXRlZFJlc3BvbnNlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBpc0NvbXBsZXhNb2RlID8gdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIGZ1bmN0aW9uUmVzcG9uc2UpKSA6IHRleHRFbmNvZGVyLmVuY29kZShmdW5jdGlvblJlc3BvbnNlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAuLi5jYWxsYmFja3MsXG4gICAgICAgICAgICBvblN0YXJ0OiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNhbGxiYWNrcy5vbkZpbmFsID0gdm9pZCAwO1xuICAgICAgICAgIGNvbnN0IG9wZW5BSVN0cmVhbSA9IE9wZW5BSVN0cmVhbShmdW5jdGlvblJlc3BvbnNlLCB7XG4gICAgICAgICAgICAuLi5maWx0ZXJlZENhbGxiYWNrcyxcbiAgICAgICAgICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXTogbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBvcGVuQUlTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtaW5nLXRleHQtcmVzcG9uc2UudHNcbnZhciBTdHJlYW1pbmdUZXh0UmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIFJlc3BvbnNlIHtcbiAgY29uc3RydWN0b3IocmVzLCBpbml0LCBkYXRhKSB7XG4gICAgbGV0IHByb2Nlc3NlZFN0cmVhbSA9IHJlcztcbiAgICBpZiAoZGF0YSkge1xuICAgICAgcHJvY2Vzc2VkU3RyZWFtID0gcmVzLnBpcGVUaHJvdWdoKGRhdGEuc3RyZWFtKTtcbiAgICB9XG4gICAgc3VwZXIocHJvY2Vzc2VkU3RyZWFtLCB7XG4gICAgICAuLi5pbml0LFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICBbQ09NUExFWF9IRUFERVJdOiBkYXRhID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsXG4gICAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gc3RyZWFtVG9SZXNwb25zZShyZXMsIHJlc3BvbnNlLCBpbml0KSB7XG4gIHJlc3BvbnNlLndyaXRlSGVhZCgoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpIHx8IDIwMCwge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICB9KTtcbiAgY29uc3QgcmVhZGVyID0gcmVzLmdldFJlYWRlcigpO1xuICBmdW5jdGlvbiByZWFkKCkge1xuICAgIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgcmVhZCgpO1xuICAgIH0pO1xuICB9XG4gIHJlYWQoKTtcbn1cblxuLy8gc3RyZWFtcy9odWdnaW5nZmFjZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcjIocmVzKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVzLm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKChfYiA9IChfYSA9IHZhbHVlLnRva2VuKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGV4dCkgIT0gbnVsbCA/IF9iIDogXCJcIik7XG4gICAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh2YWx1ZS5nZW5lcmF0ZWRfdGV4dCAhPSBudWxsICYmIHZhbHVlLmdlbmVyYXRlZF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQgPT09IFwiPC9zPlwiIHx8IHRleHQgPT09IFwiPHxlbmRvZnRleHR8PlwiIHx8IHRleHQgPT09IFwiPHxlbmR8PlwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gSHVnZ2luZ0ZhY2VTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZVBhcnNlcjIocmVzKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvY29oZXJlLXN0cmVhbS50c1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzTGluZXMobGluZXMsIGNvbnRyb2xsZXIpIHtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgeyB0ZXh0LCBpc19maW5pc2hlZCB9ID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICBpZiAoIWlzX2ZpbmlzaGVkKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcikge1xuICBsZXQgc2VnbWVudCA9IFwiXCI7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZTogY2h1bmssIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWdtZW50ICs9IHV0ZjhEZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IHNlZ21lbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL2cpO1xuICAgIHNlZ21lbnQgPSBsaW5lc0FycmF5LnBvcCgpIHx8IFwiXCI7XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmIChzZWdtZW50KSB7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IFtzZWdtZW50XTtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgY29udHJvbGxlci5jbG9zZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMyhyZXMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCByZWFkZXIgPSAoX2EgPSByZXMuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldFJlYWRlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gQ29oZXJlU3RyZWFtKHJlYWRlciwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBjcmVhdGVQYXJzZXIzKHJlYWRlcikucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhKVxuICApO1xufVxuXG4vLyBzdHJlYW1zL2FudGhyb3BpYy1zdHJlYW0udHNcbmZ1bmN0aW9uIHBhcnNlQW50aHJvcGljU3RyZWFtKCkge1xuICBsZXQgcHJldmlvdXMgPSBcIlwiO1xuICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICBpZiAoXCJlcnJvclwiIGluIGpzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtqc29uLmVycm9yLnR5cGV9OiAke2pzb24uZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgaWYgKCEoXCJjb21wbGV0aW9uXCIgaW4ganNvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGpzb24uY29tcGxldGlvbjtcbiAgICBpZiAoIXByZXZpb3VzIHx8IHRleHQubGVuZ3RoID4gcHJldmlvdXMubGVuZ3RoICYmIHRleHQuc3RhcnRzV2l0aChwcmV2aW91cykpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gdGV4dC5zbGljZShwcmV2aW91cy5sZW5ndGgpO1xuICAgICAgcHJldmlvdXMgPSB0ZXh0O1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlMihzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBjb25zdCB0ZXh0ID0gY2h1bmsuY29tcGxldGlvbjtcbiAgICBpZiAodGV4dClcbiAgICAgIHlpZWxkIHRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIEFudGhyb3BpY1N0cmVhbShyZXMsIGNiKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlMihyZXMpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQUlTdHJlYW0ocmVzLCBwYXJzZUFudGhyb3BpY1N0cmVhbSgpLCBjYikucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tc3RyZWFtLnRzXG5mdW5jdGlvbiBMYW5nQ2hhaW5TdHJlYW0oY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICBjb25zdCBydW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIGF3YWl0IHdyaXRlci5hYm9ydChlKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlU3RhcnQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmFkZChydW5JZCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUVuZCA9IGFzeW5jIChydW5JZCkgPT4ge1xuICAgIHJ1bnMuZGVsZXRlKHJ1bklkKTtcbiAgICBpZiAocnVucy5zaXplID09PSAwKSB7XG4gICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBzdHJlYW0ucmVhZGFibGUucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICAgKSxcbiAgICB3cml0ZXIsXG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIGhhbmRsZUxMTU5ld1Rva2VuOiBhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUodG9rZW4pO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTVN0YXJ0OiBhc3luYyAoX2xsbSwgX3Byb21wdHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluU3RhcnQ6IGFzeW5jIChfY2hhaW4sIF9pbnB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVuZDogYXN5bmMgKF9vdXRwdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbFN0YXJ0OiBhc3luYyAoX3Rvb2wsIF9pbnB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHN0cmVhbXMvcmVwbGljYXRlLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gUmVwbGljYXRlU3RyZWFtKHJlcywgY2IsIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB1cmwgPSAoX2EgPSByZXMudXJscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0cmVhbTtcbiAgaWYgKCF1cmwpIHtcbiAgICBpZiAocmVzLmVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcy5lcnJvcik7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzdHJlYW0gVVJMIGluIFJlcGxpY2F0ZSByZXNwb25zZVwiKTtcbiAgfVxuICBjb25zdCBldmVudFN0cmVhbSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBY2NlcHQ6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcbiAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBBSVN0cmVhbShldmVudFN0cmVhbSwgdm9pZCAwLCBjYikucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfc3RyZWFtRGF0YSlcbiAgKTtcbn1cblxuLy8gc2hhcmVkL3BhcnNlLWNvbXBsZXgtcmVzcG9uc2UudHNcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgcmVhZGVyLFxuICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gIHVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQgPSBuYW5vaWQsXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbn0pIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gZ2V0Q3VycmVudERhdGUoKTtcbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKHRydWUpO1xuICBjb25zdCBwcmVmaXhNYXAgPSB7XG4gICAgZGF0YTogW11cbiAgfTtcbiAgY29uc3QgTkVXTElORSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IGxpbmVzID0gZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcyk7XG4gICAgaWYgKHR5cGVvZiBsaW5lcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0LiBDb21wbGV4IG1vZGUgd2FzIHNldCBidXQgdGhlIHJlc3BvbnNlIGlzIGEgc3RyaW5nLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyB0eXBlLCB2YWx1ZTogdmFsdWUyIH0gb2YgbGluZXMpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInRleHRcIikge1xuICAgICAgICBpZiAocHJlZml4TWFwW1widGV4dFwiXSkge1xuICAgICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgICAuLi5wcmVmaXhNYXBbXCJ0ZXh0XCJdLFxuICAgICAgICAgICAgY29udGVudDogKHByZWZpeE1hcFtcInRleHRcIl0uY29udGVudCB8fCBcIlwiKSArIHZhbHVlMlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgY29udGVudDogdmFsdWUyLFxuICAgICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25fY2FsbFwiKSB7XG4gICAgICAgIHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl0gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgZnVuY3Rpb25fY2FsbDogdmFsdWUyLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgbmFtZTogdmFsdWUyLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl07XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXS5wdXNoKC4uLnZhbHVlMik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJ0ZXh0XCJdO1xuICAgICAgY29uc3QgbWVyZ2VkID0gW2Z1bmN0aW9uQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV0uZmlsdGVyKFxuICAgICAgICBCb29sZWFuXG4gICAgICApO1xuICAgICAgdXBkYXRlKG1lcmdlZCwgWy4uLnByZWZpeE1hcFtcImRhdGFcIl1dKTtcbiAgICAgIGlmICgoYWJvcnRDb250cm9sbGVyUmVmID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkgPT09IG51bGwpIHtcbiAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHByZWZpeE1hcCk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtwcmVmaXhNYXAudGV4dCwgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGxdLmZpbHRlcihcbiAgICAgIEJvb2xlYW5cbiAgICApLFxuICAgIGRhdGE6IHByZWZpeE1hcC5kYXRhXG4gIH07XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtaW5nLXJlYWN0LXJlc3BvbnNlLnRzXG52YXIgZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlcywgb3B0aW9ucykge1xuICAgIGxldCByZXNvbHZlRnVuYyA9ICgpID0+IHtcbiAgICB9O1xuICAgIGxldCBuZXh0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVGdW5jID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSB7XG4gICAgICBjb25zdCBwcm9jZXNzZWRTdHJlYW0gPSByZXMucGlwZVRocm91Z2goXG4gICAgICAgIG9wdGlvbnMuZGF0YS5zdHJlYW1cbiAgICAgICk7XG4gICAgICBsZXQgbGFzdFBheWxvYWQgPSB2b2lkIDA7XG4gICAgICBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gICAgICAgIHJlYWRlcjogcHJvY2Vzc2VkU3RyZWFtLmdldFJlYWRlcigpLFxuICAgICAgICB1cGRhdGU6IChtZXJnZWQsIGRhdGEpID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICBjb25zdCBjb250ZW50MiA9IChfYiA9IChfYSA9IG1lcmdlZFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQpICE9IG51bGwgPyBfYiA6IFwiXCI7XG4gICAgICAgICAgY29uc3QgdWkgPSAoKF9jID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51aSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwob3B0aW9ucywgeyBjb250ZW50OiBjb250ZW50MiwgZGF0YSB9KSkgfHwgY29udGVudDI7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHsgdWksIGNvbnRlbnQ6IGNvbnRlbnQyIH07XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2ZUZ1bmM7XG4gICAgICAgICAgY29uc3QgbmV4dFJvdyA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlRnVuYyA9IHJlc29sdmU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzb2x2ZVByZXZpb3VzKHtcbiAgICAgICAgICAgIG5leHQ6IG5leHRSb3csXG4gICAgICAgICAgICAuLi5wYXlsb2FkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGFzdFBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgICAgICBvbkZpbmlzaDogKCkgPT4ge1xuICAgICAgICAgIGlmIChsYXN0UGF5bG9hZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXNvbHZlRnVuYyh7XG4gICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgIC4uLmxhc3RQYXlsb2FkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gXCJcIjtcbiAgICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcbiAgICBjb25zdCByZWFkZXIgPSByZXMuZ2V0UmVhZGVyKCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZENodW5rKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmICghZG9uZSkge1xuICAgICAgICBjb250ZW50ICs9IGRlY29kZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCB1aSA9ICgoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCB7IGNvbnRlbnQgfSkpIHx8IGNvbnRlbnQ7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB1aSxcbiAgICAgICAgY29udGVudFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmVGdW5jO1xuICAgICAgY29uc3QgbmV4dFJvdyA9IGRvbmUgPyBudWxsIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcmVzb2x2ZUZ1bmMgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICByZXNvbHZlUHJldmlvdXMoe1xuICAgICAgICBuZXh0OiBuZXh0Um93LFxuICAgICAgICAuLi5wYXlsb2FkXG4gICAgICB9KTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRDaHVuaygpO1xuICAgIH1cbiAgICByZWFkQ2h1bmsoKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxufTtcblxuLy8gc3RyZWFtcy9hc3Npc3RhbnQtcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSh7IHRocmVhZElkLCBtZXNzYWdlSWQgfSwgcHJvY2VzczIpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgY29uc3Qgc2VuZE1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRXJyb3IgPSAoZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcImVycm9yXCIsIGVycm9yTWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiwge1xuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvY2VzczIoe1xuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICBzZW5kTWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNlbmRFcnJvcigoX2EgPSBlcnJvci5tZXNzYWdlKSAhPSBudWxsID8gX2EgOiBgJHtlcnJvcn1gKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHB1bGwoY29udHJvbGxlcikge1xuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtLCB7XG4gICAgc3RhdHVzOiAyMDAsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgQUlTdHJlYW0sXG4gIEFudGhyb3BpY1N0cmVhbSxcbiAgQ09NUExFWF9IRUFERVIsXG4gIENvaGVyZVN0cmVhbSxcbiAgSHVnZ2luZ0ZhY2VTdHJlYW0sXG4gIExhbmdDaGFpblN0cmVhbSxcbiAgT3BlbkFJU3RyZWFtLFxuICBSZXBsaWNhdGVTdHJlYW0sXG4gIFN0cmVhbWluZ1RleHRSZXNwb25zZSxcbiAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIsXG4gIGNyZWF0ZUNodW5rRGVjb2RlcixcbiAgY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcixcbiAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyLFxuICBleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhLFxuICBleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZSxcbiAgaXNTdHJlYW1TdHJpbmdFcXVhbFRvVHlwZSxcbiAgbmFub2lkLFxuICByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlLFxuICBzdHJlYW1Ub1Jlc3BvbnNlLFxuICB0cmltU3RhcnRPZlN0cmVhbUhlbHBlclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nanoid */ \"(ssr)/./node_modules/nanoid/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/utils.ts\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessage = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlData = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessage,\n    assistantControlData\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessage.code]: assistantMessage,\n    [assistantControlData.code]: assistantControlData\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessage.name]: assistantMessage.code,\n    [assistantControlData.name]: assistantControlData.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/utils.ts\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// shared/call-api.ts\n\n// shared/parse-complex-response.ts\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId = nanoid, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const decode = createChunkDecoder(true);\n    const prefixMap = {\n        data: []\n    };\n    const NEWLINE = \"\\n\".charCodeAt(0);\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        let concatenatedChunks = new Uint8Array(totalLength);\n        let offset = 0;\n        for (const chunk of chunks){\n            concatenatedChunks.set(chunk, offset);\n            offset += chunk.length;\n        }\n        chunks.length = 0;\n        totalLength = 0;\n        const lines = decode(concatenatedChunks);\n        if (typeof lines === \"string\") {\n            throw new Error(\"Invalid response format. Complex mode was set but the response is a string. This should never happen.\");\n        }\n        for (const { type, value: value2 } of lines){\n            if (type === \"text\") {\n                if (prefixMap[\"text\"]) {\n                    prefixMap[\"text\"] = {\n                        ...prefixMap[\"text\"],\n                        content: (prefixMap[\"text\"].content || \"\") + value2\n                    };\n                } else {\n                    prefixMap[\"text\"] = {\n                        id: generateId(),\n                        role: \"assistant\",\n                        content: value2,\n                        createdAt\n                    };\n                }\n            }\n            let functionCallMessage = null;\n            if (type === \"function_call\") {\n                prefixMap[\"function_call\"] = {\n                    id: generateId(),\n                    role: \"assistant\",\n                    content: \"\",\n                    function_call: value2.function_call,\n                    name: value2.function_call.name,\n                    createdAt\n                };\n                functionCallMessage = prefixMap[\"function_call\"];\n            }\n            if (type === \"data\") {\n                prefixMap[\"data\"].push(...value2);\n            }\n            const responseMessage = prefixMap[\"text\"];\n            const merged = [\n                functionCallMessage,\n                responseMessage\n            ].filter(Boolean);\n            update(merged, [\n                ...prefixMap[\"data\"]\n            ]);\n            if ((abortControllerRef == null ? void 0 : abortControllerRef.current) === null) {\n                reader.cancel();\n                break;\n            }\n        }\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/call-api.ts\nasync function callApi({ api, messages, body, credentials, headers, abortController, appendMessage, restoreMessagesOnFailure, onResponse, onUpdate, onFinish }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers,\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    const isComplexMode = response.headers.get(COMPLEX_HEADER) === \"true\";\n    if (isComplexMode) {\n        return await parseComplexResponse({\n            reader,\n            abortControllerRef: abortController != null ? {\n                current: abortController()\n            } : void 0,\n            update: onUpdate,\n            onFinish (prefixMap) {\n                if (onFinish && prefixMap.text != null) {\n                    onFinish(prefixMap.text);\n                }\n            }\n        });\n    } else {\n        const createdAt = /* @__PURE__ */ new Date();\n        const decode = createChunkDecoder(false);\n        let streamedResponse = \"\";\n        const replyId = (0,nanoid__WEBPACK_IMPORTED_MODULE_3__.nanoid)();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            streamedResponse += decode(value);\n            if (streamedResponse.startsWith('{\"function_call\":')) {\n                responseMessage[\"function_call\"] = streamedResponse;\n            } else {\n                responseMessage[\"content\"] = streamedResponse;\n            }\n            appendMessage({\n                ...responseMessage\n            });\n            if ((abortController == null ? void 0 : abortController()) === null) {\n                reader.cancel();\n                break;\n            }\n        }\n        if (streamedResponse.startsWith('{\"function_call\":')) {\n            const parsedFunctionCall = JSON.parse(streamedResponse).function_call;\n            responseMessage[\"function_call\"] = parsedFunctionCall;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if (message.function_call === void 0 || typeof message.function_call === \"string\") {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if (streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                updateChatRequest(functionCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call })=>({\n            role,\n            content,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = nanoid();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            }\n        },\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        appendMessage (message) {\n            mutate([\n                ...chatRequest.messages,\n                message\n            ], false);\n        },\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, onResponse, onFinish, onError, credentials, headers, body } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const chatId = id || hookId;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        chatId\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatId,\n        \"streamData\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        messagesRef.current,\n        abortControllerRef.current\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, data } = {})=>{\n        if (!message.id) {\n            message.id = nanoid();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController2 = new AbortController();\n            setAbortController(abortController2);\n            mutate(\"\", false);\n            const res = await fetch(api, {\n                method: \"POST\",\n                body: JSON.stringify({\n                    prompt,\n                    ...extraMetadataRef.current.body,\n                    ...options == null ? void 0 : options.body\n                }),\n                credentials: extraMetadataRef.current.credentials,\n                headers: {\n                    ...extraMetadataRef.current.headers,\n                    ...options == null ? void 0 : options.headers\n                },\n                signal: abortController2.signal\n            }).catch((err)=>{\n                throw err;\n            });\n            if (onResponse) {\n                try {\n                    await onResponse(res);\n                } catch (err) {\n                    throw err;\n                }\n            }\n            if (!res.ok) {\n                throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n            }\n            if (!res.body) {\n                throw new Error(\"The response body is empty.\");\n            }\n            let result = \"\";\n            const reader = res.body.getReader();\n            const decoder = createChunkDecoder();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                result += decoder(value);\n                mutate(result, false);\n                if (abortController2 === null) {\n                    reader.cancel();\n                    break;\n                }\n            }\n            if (onFinish) {\n                onFinish(prompt, result);\n            }\n            setAbortController(null);\n            return result;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                setAbortController(null);\n                return null;\n            }\n            if (err instanceof Error) {\n                if (onError) {\n                    onError(err);\n                }\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading\n    };\n}\n// react/use-assistant.ts\n\n// shared/process-message-stream.ts\nasync function processMessageStream(reader, processMessage) {\n    const decoder = new TextDecoder();\n    let buffer = \"\";\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            if (buffer.length > 0) {\n                processMessage(buffer);\n            }\n            break;\n        }\n        buffer += decoder.decode(value, {\n            stream: true\n        });\n        let endIndex;\n        while((endIndex = buffer.indexOf(\"\\n\")) !== -1){\n            processMessage(buffer.substring(0, endIndex).trim());\n            buffer = buffer.substring(endIndex + 1);\n        }\n    }\n}\n// react/use-assistant.ts\nfunction experimental_useAssistant({ api, threadId: threadIdParam }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    const submitMessage = async (e)=>{\n        var _a;\n        e.preventDefault();\n        if (input === \"\") {\n            return;\n        }\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>[\n                ...messages2,\n                {\n                    id: \"\",\n                    role: \"user\",\n                    content: input\n                }\n            ]);\n        setInput(\"\");\n        const result = await fetch(api, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                // always use user-provided threadId when available:\n                threadId: (_a = threadIdParam != null ? threadIdParam : threadId) != null ? _a : null,\n                message: input\n            })\n        });\n        if (result.body == null) {\n            throw new Error(\"The response body is empty.\");\n        }\n        await processMessageStream(result.body.getReader(), (message)=>{\n            try {\n                const { type, value } = parseStreamPart(message);\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            setError(value);\n                            break;\n                        }\n                }\n            } catch (error2) {\n                setError(error2);\n            }\n        });\n        setStatus(\"awaiting_message\");\n    };\n    return {\n        messages,\n        input,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztxR0FFQSxvQkFBb0I7QUFDb0Q7QUFDL0M7QUFFekIsa0JBQWtCO0FBQ2lDO0FBRW5ELHlCQUF5QjtBQUN6QixJQUFJTyxpQkFBaUI7SUFDbkJDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQVFGO1FBQU07SUFDL0I7QUFDRjtBQUNBLElBQUlHLHlCQUF5QjtJQUMzQk4sTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsb0JBQW1CQSxLQUFJLEtBQU0sT0FBT0EsTUFBTUksYUFBYSxLQUFLLFlBQVlKLE1BQU1JLGFBQWEsSUFBSSxRQUFRLENBQUUsV0FBVUosTUFBTUksYUFBYSxLQUFLLENBQUUsZ0JBQWVKLE1BQU1JLGFBQWEsS0FBSyxPQUFPSixNQUFNSSxhQUFhLENBQUNOLElBQUksS0FBSyxZQUFZLE9BQU9FLE1BQU1JLGFBQWEsQ0FBQ0MsU0FBUyxLQUFLLFVBQVU7WUFDelUsTUFBTSxJQUFJSixNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJTSxpQkFBaUI7SUFDbkJULE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxDQUFDTyxNQUFNQyxPQUFPLENBQUNSLFFBQVE7WUFDekIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQVFGO1FBQU07SUFDL0I7QUFDRjtBQUNBLElBQUlTLGtCQUFrQjtJQUNwQlosTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJ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QVk7NEJBQ25FOzRCQUNBO3dCQUNGO29CQUNBLEtBQUs7d0JBQVM7NEJBQ1pQLFNBQVNwSjs0QkFDVDt3QkFDRjtnQkFDRjtZQUNGLEVBQUUsT0FBT3VNLFFBQVE7Z0JBQ2ZuRCxTQUFTbUQ7WUFDWDtRQUNGO1FBQ0FGLFVBQVU7SUFDWjtJQUNBLE9BQU87UUFDTHRIO1FBQ0FrRjtRQUNBSztRQUNBZ0M7UUFDQUY7UUFDQWpEO0lBQ0Y7QUFDRjtBQUtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktY29tcGFuaW9uLy4vbm9kZV9tb2R1bGVzL2FpL3JlYWN0L2Rpc3QvaW5kZXgubWpzPzJiZmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIHJlYWN0L3VzZS1jaGF0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUiBmcm9tIFwic3dyXCI7XG5cbi8vIHNoYXJlZC91dGlscy50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcblxuLy8gc2hhcmVkL3N0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIxXCIsXG4gIG5hbWU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmdW5jdGlvbl9jYWxsXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fCAhKFwibmFtZVwiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fCB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjJcIixcbiAgbmFtZTogXCJkYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50TWVzc2FnZSA9IHtcbiAgY29kZTogXCI0XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB2YWx1ZSkgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImNvbnRlbnRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmlkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHwgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAoaXRlbSkgPT4gaXRlbSAhPSBudWxsICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGl0ZW0gJiYgaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtICYmIGl0ZW0udGV4dCAhPSBudWxsICYmIHR5cGVvZiBpdGVtLnRleHQgPT09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIGl0ZW0udGV4dCAmJiB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRDb250cm9sRGF0YSA9IHtcbiAgY29kZTogXCI1XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0aHJlYWRJZFwiIGluIHZhbHVlKSB8fCAhKFwibWVzc2FnZUlkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50aHJlYWRJZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUubWVzc2FnZUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRocmVhZElkXCIgYW5kIFwibWVzc2FnZUlkXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZFxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgc3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0LFxuICBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBkYXRhU3RyZWFtUGFydCxcbiAgZXJyb3JTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRNZXNzYWdlLFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVxuXTtcbnZhciBzdHJlYW1QYXJ0c0J5Q29kZSA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0LmNvZGVdOiB0ZXh0U3RyZWFtUGFydCxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIFtkYXRhU3RyZWFtUGFydC5jb2RlXTogZGF0YVN0cmVhbVBhcnQsXG4gIFtlcnJvclN0cmVhbVBhcnQuY29kZV06IGVycm9yU3RyZWFtUGFydCxcbiAgW2Fzc2lzdGFudE1lc3NhZ2UuY29kZV06IGFzc2lzdGFudE1lc3NhZ2UsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YS5jb2RlXTogYXNzaXN0YW50Q29udHJvbERhdGFcbn07XG52YXIgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5uYW1lXTogdGV4dFN0cmVhbVBhcnQuY29kZSxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQubmFtZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2UubmFtZV06IGFzc2lzdGFudE1lc3NhZ2UuY29kZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhLm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YS5jb2RlXG59O1xudmFyIHZhbGlkQ29kZXMgPSBzdHJlYW1QYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQuY29kZSk7XG52YXIgcGFyc2VTdHJlYW1QYXJ0ID0gKGxpbmUpID0+IHtcbiAgY29uc3QgZmlyc3RTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gIGlmIChmaXJzdFNlcGFyYXRvckluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuXCIpO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGxpbmUuc2xpY2UoMCwgZmlyc3RTZXBhcmF0b3JJbmRleCk7XG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gSW52YWxpZCBjb2RlICR7cHJlZml4fS5gKTtcbiAgfVxuICBjb25zdCBjb2RlID0gcHJlZml4O1xuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlID0gSlNPTi5wYXJzZSh0ZXh0VmFsdWUpO1xuICByZXR1cm4gc3RyZWFtUGFydHNCeUNvZGVbY29kZV0ucGFyc2UoanNvblZhbHVlKTtcbn07XG5cbi8vIHNoYXJlZC91dGlscy50c1xudmFyIG5hbm9pZCA9IGN1c3RvbUFscGhhYmV0KFxuICBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsXG4gIDdcbik7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoY29tcGxleCkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGlmICghY29tcGxleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgaWYgKCFjaHVuaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpO1xuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cbnZhciBDT01QTEVYX0hFQURFUiA9IFwiWC1FeHBlcmltZW50YWwtU3RyZWFtLURhdGFcIjtcblxuLy8gc2hhcmVkL2NhbGwtYXBpLnRzXG5pbXBvcnQgeyBuYW5vaWQgYXMgbmFub2lkMiB9IGZyb20gXCJuYW5vaWRcIjtcblxuLy8gc2hhcmVkL3BhcnNlLWNvbXBsZXgtcmVzcG9uc2UudHNcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgcmVhZGVyLFxuICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gIHVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQgPSBuYW5vaWQsXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbn0pIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gZ2V0Q3VycmVudERhdGUoKTtcbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKHRydWUpO1xuICBjb25zdCBwcmVmaXhNYXAgPSB7XG4gICAgZGF0YTogW11cbiAgfTtcbiAgY29uc3QgTkVXTElORSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IGxpbmVzID0gZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcyk7XG4gICAgaWYgKHR5cGVvZiBsaW5lcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgcmVzcG9uc2UgZm9ybWF0LiBDb21wbGV4IG1vZGUgd2FzIHNldCBidXQgdGhlIHJlc3BvbnNlIGlzIGEgc3RyaW5nLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyB0eXBlLCB2YWx1ZTogdmFsdWUyIH0gb2YgbGluZXMpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInRleHRcIikge1xuICAgICAgICBpZiAocHJlZml4TWFwW1widGV4dFwiXSkge1xuICAgICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgICAuLi5wcmVmaXhNYXBbXCJ0ZXh0XCJdLFxuICAgICAgICAgICAgY29udGVudDogKHByZWZpeE1hcFtcInRleHRcIl0uY29udGVudCB8fCBcIlwiKSArIHZhbHVlMlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgY29udGVudDogdmFsdWUyLFxuICAgICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25fY2FsbFwiKSB7XG4gICAgICAgIHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl0gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgZnVuY3Rpb25fY2FsbDogdmFsdWUyLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgbmFtZTogdmFsdWUyLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl07XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXS5wdXNoKC4uLnZhbHVlMik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJ0ZXh0XCJdO1xuICAgICAgY29uc3QgbWVyZ2VkID0gW2Z1bmN0aW9uQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV0uZmlsdGVyKFxuICAgICAgICBCb29sZWFuXG4gICAgICApO1xuICAgICAgdXBkYXRlKG1lcmdlZCwgWy4uLnByZWZpeE1hcFtcImRhdGFcIl1dKTtcbiAgICAgIGlmICgoYWJvcnRDb250cm9sbGVyUmVmID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkgPT09IG51bGwpIHtcbiAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHByZWZpeE1hcCk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtwcmVmaXhNYXAudGV4dCwgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGxdLmZpbHRlcihcbiAgICAgIEJvb2xlYW5cbiAgICApLFxuICAgIGRhdGE6IHByZWZpeE1hcC5kYXRhXG4gIH07XG59XG5cbi8vIHNoYXJlZC9jYWxsLWFwaS50c1xuYXN5bmMgZnVuY3Rpb24gY2FsbEFwaSh7XG4gIGFwaSxcbiAgbWVzc2FnZXMsXG4gIGJvZHksXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIGFwcGVuZE1lc3NhZ2UsXG4gIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSxcbiAgb25SZXNwb25zZSxcbiAgb25VcGRhdGUsXG4gIG9uRmluaXNoXG59KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgLi4uYm9keVxuICAgIH0pLFxuICAgIGhlYWRlcnMsXG4gICAgc2lnbmFsOiAoX2EgPSBhYm9ydENvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzXG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuICBpZiAob25SZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGF3YWl0IHJlc3BvbnNlLnRleHQoKSB8fCBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGlzQ29tcGxleE1vZGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChDT01QTEVYX0hFQURFUikgPT09IFwidHJ1ZVwiO1xuICBpZiAoaXNDb21wbGV4TW9kZSkge1xuICAgIHJldHVybiBhd2FpdCBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gICAgICByZWFkZXIsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWY6IGFib3J0Q29udHJvbGxlciAhPSBudWxsID8geyBjdXJyZW50OiBhYm9ydENvbnRyb2xsZXIoKSB9IDogdm9pZCAwLFxuICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgIG9uRmluaXNoKHByZWZpeE1hcCkge1xuICAgICAgICBpZiAob25GaW5pc2ggJiYgcHJlZml4TWFwLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIG9uRmluaXNoKHByZWZpeE1hcC50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcihmYWxzZSk7XG4gICAgbGV0IHN0cmVhbWVkUmVzcG9uc2UgPSBcIlwiO1xuICAgIGNvbnN0IHJlcGx5SWQgPSBuYW5vaWQyKCk7XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHtcbiAgICAgIGlkOiByZXBseUlkLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgY29udGVudDogXCJcIixcbiAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCJcbiAgICB9O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdHJlYW1lZFJlc3BvbnNlICs9IGRlY29kZSh2YWx1ZSk7XG4gICAgICBpZiAoc3RyZWFtZWRSZXNwb25zZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykpIHtcbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHN0cmVhbWVkUmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZU1lc3NhZ2VbXCJjb250ZW50XCJdID0gc3RyZWFtZWRSZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIGFwcGVuZE1lc3NhZ2UoeyAuLi5yZXNwb25zZU1lc3NhZ2UgfSk7XG4gICAgICBpZiAoKGFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyKCkpID09PSBudWxsKSB7XG4gICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJlYW1lZFJlc3BvbnNlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSkge1xuICAgICAgY29uc3QgcGFyc2VkRnVuY3Rpb25DYWxsID0gSlNPTi5wYXJzZShzdHJlYW1lZFJlc3BvbnNlKS5mdW5jdGlvbl9jYWxsO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHBhcnNlZEZ1bmN0aW9uQ2FsbDtcbiAgICAgIGFwcGVuZE1lc3NhZ2UoeyAuLi5yZXNwb25zZU1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxufVxuXG4vLyBzaGFyZWQvcHJvY2Vzcy1jaGF0LXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlOiBnZXRTdHJlYW1lZFJlc3BvbnNlMixcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICB1cGRhdGVDaGF0UmVxdWVzdCxcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzXG59KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSA9IGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UyKCk7XG4gICAgaWYgKFwibWVzc2FnZXNcIiBpbiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlKSB7XG4gICAgICBsZXQgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCB8fCB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzKCksXG4gICAgICAgICAgICBmdW5jdGlvbkNhbGxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNGb2xsb3dpbmdSZXNwb25zZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlO1xuICAgICAgaWYgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCB8fCB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIGZ1bmN0aW9uQ2FsbCk7XG4gICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdChmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlYWN0L3VzZS1jaGF0LnRzXG52YXIgZ2V0U3RyZWFtZWRSZXNwb25zZSA9IGFzeW5jIChhcGksIGNoYXRSZXF1ZXN0LCBtdXRhdGUsIG11dGF0ZVN0cmVhbURhdGEsIGV4aXN0aW5nRGF0YSwgZXh0cmFNZXRhZGF0YVJlZiwgbWVzc2FnZXNSZWYsIGFib3J0Q29udHJvbGxlclJlZiwgb25GaW5pc2gsIG9uUmVzcG9uc2UsIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcHJldmlvdXNNZXNzYWdlcyA9IG1lc3NhZ2VzUmVmLmN1cnJlbnQ7XG4gIG11dGF0ZShjaGF0UmVxdWVzdC5tZXNzYWdlcywgZmFsc2UpO1xuICBjb25zdCBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCA9IHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMgPyBjaGF0UmVxdWVzdC5tZXNzYWdlcyA6IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLm1hcCgoeyByb2xlLCBjb250ZW50LCBuYW1lLCBmdW5jdGlvbl9jYWxsIH0pID0+ICh7XG4gICAgcm9sZSxcbiAgICBjb250ZW50LFxuICAgIC4uLm5hbWUgIT09IHZvaWQgMCAmJiB7IG5hbWUgfSxcbiAgICAuLi5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYge1xuICAgICAgZnVuY3Rpb25fY2FsbFxuICAgIH1cbiAgfSkpO1xuICBpZiAodHlwZW9mIGFwaSAhPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHJlcGx5SWQgPSBuYW5vaWQoKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgaWQ6IHJlcGx5SWQsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIlxuICAgIH07XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZFJvdyhwcm9taXNlKSB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIHVpLCBuZXh0IH0gPSBhd2FpdCBwcm9taXNlO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlW1wiY29udGVudFwiXSA9IGNvbnRlbnQ7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJ1aVwiXSA9IGF3YWl0IHVpO1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgeyAuLi5yZXNwb25zZU1lc3NhZ2UgfV0sIGZhbHNlKTtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGF3YWl0IHJlYWRSb3cobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gYXBpKHtcbiAgICAgICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkLFxuICAgICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHJlYWRSb3cocHJvbWlzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxuICByZXR1cm4gYXdhaXQgY2FsbEFwaSh7XG4gICAgYXBpLFxuICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCxcbiAgICBib2R5OiB7XG4gICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmJvZHksXG4gICAgICAuLi4oX2EgPSBjaGF0UmVxdWVzdC5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYm9keSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgZnVuY3Rpb25zOiBjaGF0UmVxdWVzdC5mdW5jdGlvbnNcbiAgICAgIH0sXG4gICAgICAuLi5jaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYge1xuICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLFxuICAgICAgLi4uKF9iID0gY2hhdFJlcXVlc3Qub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhlYWRlcnNcbiAgICB9LFxuICAgIGFib3J0Q29udHJvbGxlcjogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQsXG4gICAgYXBwZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBtZXNzYWdlXSwgZmFsc2UpO1xuICAgIH0sXG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25VcGRhdGUobWVyZ2VkLCBkYXRhKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCAuLi5tZXJnZWRdLCBmYWxzZSk7XG4gICAgICBtdXRhdGVTdHJlYW1EYXRhKFsuLi5leGlzdGluZ0RhdGEgfHwgW10sIC4uLmRhdGEgfHwgW11dLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvbkZpbmlzaFxuICB9KTtcbn07XG5mdW5jdGlvbiB1c2VDaGF0KHtcbiAgYXBpID0gXCIvYXBpL2NoYXRcIixcbiAgaWQsXG4gIGluaXRpYWxNZXNzYWdlcyxcbiAgaW5pdGlhbElucHV0ID0gXCJcIixcbiAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHlcbn0gPSB7fSkge1xuICBjb25zdCBob29rSWQgPSB1c2VJZCgpO1xuICBjb25zdCBjaGF0SWQgPSBpZCB8fCBob29rSWQ7XG4gIGNvbnN0IFtpbml0aWFsTWVzc2FnZXNGYWxsYmFja10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHsgZGF0YTogbWVzc2FnZXMsIG11dGF0ZSB9ID0gdXNlU1dSKFthcGksIGNoYXRJZF0sIG51bGwsIHtcbiAgICBmYWxsYmFja0RhdGE6IGluaXRpYWxNZXNzYWdlcyAhPSBudWxsID8gaW5pdGlhbE1lc3NhZ2VzIDogaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2tcbiAgfSk7XG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSKFxuICAgIFtjaGF0SWQsIFwibG9hZGluZ1wiXSxcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IHsgZGF0YTogc3RyZWFtRGF0YSwgbXV0YXRlOiBtdXRhdGVTdHJlYW1EYXRhIH0gPSB1c2VTV1IoW2NoYXRJZCwgXCJzdHJlYW1EYXRhXCJdLCBudWxsKTtcbiAgY29uc3QgbWVzc2FnZXNSZWYgPSB1c2VSZWYobWVzc2FnZXMgfHwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlcyB8fCBbXTtcbiAgfSwgW21lc3NhZ2VzXSk7XG4gIGNvbnN0IGFib3J0Q29udHJvbGxlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZSgpO1xuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjaGF0UmVxdWVzdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICAgICAgICAgIGdldFN0cmVhbWVkUmVzcG9uc2U6ICgpID0+IGdldFN0cmVhbWVkUmVzcG9uc2UoXG4gICAgICAgICAgICBhcGksXG4gICAgICAgICAgICBjaGF0UmVxdWVzdCxcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICAgICAgICBzdHJlYW1EYXRhLFxuICAgICAgICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgICAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgICAgICAgb25GaW5pc2gsXG4gICAgICAgICAgICBvblJlc3BvbnNlLFxuICAgICAgICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkc1xuICAgICAgICAgICksXG4gICAgICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0OiAoY2hhdFJlcXVlc3RQYXJhbSkgPT4ge1xuICAgICAgICAgICAgY2hhdFJlcXVlc3QgPSBjaGF0UmVxdWVzdFBhcmFtO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzOiAoKSA9PiBtZXNzYWdlc1JlZi5jdXJyZW50XG4gICAgICAgIH0pO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRFcnJvcihlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICBzdHJlYW1EYXRhLFxuICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudFxuICAgIF1cbiAgKTtcbiAgY29uc3QgYXBwZW5kID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKG1lc3NhZ2UsIHsgb3B0aW9ucywgZnVuY3Rpb25zLCBmdW5jdGlvbl9jYWxsLCBkYXRhIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKCFtZXNzYWdlLmlkKSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBuYW5vaWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5jb25jYXQobWVzc2FnZSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIC4uLmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25zIH0sXG4gICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdXG4gICk7XG4gIGNvbnN0IHJlbG9hZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh7IG9wdGlvbnMsIGZ1bmN0aW9ucywgZnVuY3Rpb25fY2FsbCB9ID0ge30pID0+IHtcbiAgICAgIGlmIChtZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzUmVmLmN1cnJlbnRbbWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0TWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiKSB7XG4gICAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0MiA9IHtcbiAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5zbGljZSgwLCAtMSksXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAuLi5mdW5jdGlvbnMgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9ucyB9LFxuICAgICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LmFib3J0KCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHNldE1lc3NhZ2VzID0gdXNlQ2FsbGJhY2soXG4gICAgKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgbXV0YXRlKG1lc3NhZ2VzMiwgZmFsc2UpO1xuICAgICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzMjtcbiAgICB9LFxuICAgIFttdXRhdGVdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoaW5pdGlhbElucHV0KTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKGUsIG9wdGlvbnMgPSB7fSwgbWV0YWRhdGEpID0+IHtcbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgIC4uLm1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KVxuICAgICAgICByZXR1cm47XG4gICAgICBhcHBlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBjb250ZW50OiBpbnB1dCxcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjcmVhdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgICBzZXRJbnB1dChcIlwiKTtcbiAgICB9LFxuICAgIFtpbnB1dCwgYXBwZW5kXVxuICApO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlKSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCBbXSxcbiAgICBlcnJvcixcbiAgICBhcHBlbmQsXG4gICAgcmVsb2FkLFxuICAgIHN0b3AsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhXG4gIH07XG59XG5cbi8vIHJlYWN0L3VzZS1jb21wbGV0aW9uLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VJZCBhcyB1c2VJZDIsIHVzZVJlZiBhcyB1c2VSZWYyLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB1c2VTV1IyIGZyb20gXCJzd3JcIjtcbmZ1bmN0aW9uIHVzZUNvbXBsZXRpb24oe1xuICBhcGkgPSBcIi9hcGkvY29tcGxldGlvblwiLFxuICBpZCxcbiAgaW5pdGlhbENvbXBsZXRpb24gPSBcIlwiLFxuICBpbml0aWFsSW5wdXQgPSBcIlwiLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3Jcbn0gPSB7fSkge1xuICBjb25zdCBob29rSWQgPSB1c2VJZDIoKTtcbiAgY29uc3QgY29tcGxldGlvbklkID0gaWQgfHwgaG9va0lkO1xuICBjb25zdCB7IGRhdGEsIG11dGF0ZSB9ID0gdXNlU1dSMihbYXBpLCBjb21wbGV0aW9uSWRdLCBudWxsLCB7XG4gICAgZmFsbGJhY2tEYXRhOiBpbml0aWFsQ29tcGxldGlvblxuICB9KTtcbiAgY29uc3QgeyBkYXRhOiBpc0xvYWRpbmcgPSBmYWxzZSwgbXV0YXRlOiBtdXRhdGVMb2FkaW5nIH0gPSB1c2VTV1IyKFxuICAgIFtjb21wbGV0aW9uSWQsIFwibG9hZGluZ1wiXSxcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUyKHZvaWQgMCk7XG4gIGNvbnN0IGNvbXBsZXRpb24gPSBkYXRhO1xuICBjb25zdCBbYWJvcnRDb250cm9sbGVyLCBzZXRBYm9ydENvbnRyb2xsZXJdID0gdXNlU3RhdGUyKG51bGwpO1xuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmMih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5XG4gIH0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jIChwcm9tcHQsIG9wdGlvbnMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlcjIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHNldEFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIyKTtcbiAgICAgICAgbXV0YXRlKFwiXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyMi5zaWduYWxcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBhd2FpdCByZXMudGV4dCgpIHx8IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgKz0gZGVjb2Rlcih2YWx1ZSk7XG4gICAgICAgICAgbXV0YXRlKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldEVycm9yKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yXG4gICAgXVxuICApO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2syKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICB9XG4gIH0sIFthYm9ydENvbnRyb2xsZXJdKTtcbiAgY29uc3Qgc2V0Q29tcGxldGlvbiA9IHVzZUNhbGxiYWNrMihcbiAgICAoY29tcGxldGlvbjIpID0+IHtcbiAgICAgIG11dGF0ZShjb21wbGV0aW9uMiwgZmFsc2UpO1xuICAgIH0sXG4gICAgW211dGF0ZV1cbiAgKTtcbiAgY29uc3QgY29tcGxldGUgPSB1c2VDYWxsYmFjazIoXG4gICAgYXN5bmMgKHByb21wdCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KHByb21wdCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUyKGluaXRpYWxJbnB1dCk7XG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrMihcbiAgICAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlKGlucHV0KTtcbiAgICB9LFxuICAgIFtpbnB1dCwgY29tcGxldGVdXG4gICk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGUpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgY29tcGxldGlvbixcbiAgICBjb21wbGV0ZSxcbiAgICBlcnJvcixcbiAgICBzZXRDb21wbGV0aW9uLFxuICAgIHN0b3AsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZ1xuICB9O1xufVxuXG4vLyByZWFjdC91c2UtYXNzaXN0YW50LnRzXG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTMgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc2hhcmVkL3Byb2Nlc3MtbWVzc2FnZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlU3RyZWFtKHJlYWRlciwgcHJvY2Vzc01lc3NhZ2UpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHJvY2Vzc01lc3NhZ2UoYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIGxldCBlbmRJbmRleDtcbiAgICB3aGlsZSAoKGVuZEluZGV4ID0gYnVmZmVyLmluZGV4T2YoXCJcXG5cIikpICE9PSAtMSkge1xuICAgICAgcHJvY2Vzc01lc3NhZ2UoYnVmZmVyLnN1YnN0cmluZygwLCBlbmRJbmRleCkudHJpbSgpKTtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHJpbmcoZW5kSW5kZXggKyAxKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcmVhY3QvdXNlLWFzc2lzdGFudC50c1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCh7XG4gIGFwaSxcbiAgdGhyZWFkSWQ6IHRocmVhZElkUGFyYW1cbn0pIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTMoW10pO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlMyhcIlwiKTtcbiAgY29uc3QgW3RocmVhZElkLCBzZXRUaHJlYWRJZF0gPSB1c2VTdGF0ZTModm9pZCAwKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlMyhcImF3YWl0aW5nX21lc3NhZ2VcIik7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUzKHZvaWQgMCk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGUpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG4gIGNvbnN0IHN1Ym1pdE1lc3NhZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGlucHV0ID09PSBcIlwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFN0YXR1cyhcImluX3Byb2dyZXNzXCIpO1xuICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IFtcbiAgICAgIC4uLm1lc3NhZ2VzMixcbiAgICAgIHsgaWQ6IFwiXCIsIHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBpbnB1dCB9XG4gICAgXSk7XG4gICAgc2V0SW5wdXQoXCJcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAvLyBhbHdheXMgdXNlIHVzZXItcHJvdmlkZWQgdGhyZWFkSWQgd2hlbiBhdmFpbGFibGU6XG4gICAgICAgIHRocmVhZElkOiAoX2EgPSB0aHJlYWRJZFBhcmFtICE9IG51bGwgPyB0aHJlYWRJZFBhcmFtIDogdGhyZWFkSWQpICE9IG51bGwgPyBfYSA6IG51bGwsXG4gICAgICAgIG1lc3NhZ2U6IGlucHV0XG4gICAgICB9KVxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGF3YWl0IHByb2Nlc3NNZXNzYWdlU3RyZWFtKHJlc3VsdC5ib2R5LmdldFJlYWRlcigpLCAobWVzc2FnZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gcGFyc2VTdHJlYW1QYXJ0KG1lc3NhZ2UpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYXNzaXN0YW50X21lc3NhZ2VcIjoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlczIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgcm9sZTogdmFsdWUucm9sZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50WzBdLnRleHQudmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIjoge1xuICAgICAgICAgICAgc2V0VGhyZWFkSWQodmFsdWUudGhyZWFkSWQpO1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzMlttZXNzYWdlczIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmlkID0gdmFsdWUubWVzc2FnZUlkO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLm1lc3NhZ2VzMi5zbGljZSgwLCBtZXNzYWdlczIubGVuZ3RoIC0gMSksIGxhc3RNZXNzYWdlXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICBzZXRFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBzZXRFcnJvcihlcnJvcjIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNldFN0YXR1cyhcImF3YWl0aW5nX21lc3NhZ2VcIik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgc3VibWl0TWVzc2FnZSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3JcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQsXG4gIHVzZUNoYXQsXG4gIHVzZUNvbXBsZXRpb25cbn07XG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU1dSIiwiY3VzdG9tQWxwaGFiZXQiLCJ0ZXh0U3RyZWFtUGFydCIsImNvZGUiLCJuYW1lIiwicGFyc2UiLCJ2YWx1ZSIsIkVycm9yIiwidHlwZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlIiwiaWQiLCJyb2xlIiwiY29udGVudCIsImV2ZXJ5IiwiaXRlbSIsInRleHQiLCJhc3Npc3RhbnRDb250cm9sRGF0YSIsInRocmVhZElkIiwibWVzc2FnZUlkIiwic3RyZWFtUGFydHMiLCJzdHJlYW1QYXJ0c0J5Q29kZSIsIlN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlcyIsIm1hcCIsInBhcnQiLCJwYXJzZVN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJzbGljZSIsImluY2x1ZGVzIiwidGV4dFZhbHVlIiwianNvblZhbHVlIiwiSlNPTiIsIm5hbm9pZCIsImNyZWF0ZUNodW5rRGVjb2RlciIsImNvbXBsZXgiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJjaHVuayIsImRlY29kZSIsInN0cmVhbSIsImRlY29kZWQiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJDT01QTEVYX0hFQURFUiIsIm5hbm9pZDIiLCJwYXJzZUNvbXBsZXhSZXNwb25zZSIsInJlYWRlciIsImFib3J0Q29udHJvbGxlclJlZiIsInVwZGF0ZSIsIm9uRmluaXNoIiwiZ2VuZXJhdGVJZCIsImdldEN1cnJlbnREYXRlIiwiRGF0ZSIsImNyZWF0ZWRBdCIsInByZWZpeE1hcCIsImRhdGEiLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwicmVhZCIsInB1c2giLCJsZW5ndGgiLCJjb25jYXRlbmF0ZWRDaHVua3MiLCJVaW50OEFycmF5Iiwib2Zmc2V0Iiwic2V0IiwibGluZXMiLCJ2YWx1ZTIiLCJmdW5jdGlvbkNhbGxNZXNzYWdlIiwicmVzcG9uc2VNZXNzYWdlIiwibWVyZ2VkIiwiY3VycmVudCIsImNhbmNlbCIsIm1lc3NhZ2VzIiwiY2FsbEFwaSIsImFwaSIsImJvZHkiLCJjcmVkZW50aWFscyIsImhlYWRlcnMiLCJhYm9ydENvbnRyb2xsZXIiLCJhcHBlbmRNZXNzYWdlIiwicmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlIiwib25SZXNwb25zZSIsIm9uVXBkYXRlIiwiX2EiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwic3RyaW5naWZ5Iiwic2lnbmFsIiwiY2F0Y2giLCJlcnIiLCJvayIsImdldFJlYWRlciIsImlzQ29tcGxleE1vZGUiLCJnZXQiLCJzdHJlYW1lZFJlc3BvbnNlIiwicmVwbHlJZCIsImRvbmUiLCJzdGFydHNXaXRoIiwicGFyc2VkRnVuY3Rpb25DYWxsIiwicHJvY2Vzc0NoYXRTdHJlYW0iLCJnZXRTdHJlYW1lZFJlc3BvbnNlIiwiZ2V0U3RyZWFtZWRSZXNwb25zZTIiLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJ1cGRhdGVDaGF0UmVxdWVzdCIsImdldEN1cnJlbnRNZXNzYWdlcyIsIm1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UiLCJoYXNGb2xsb3dpbmdSZXNwb25zZSIsIm1lc3NhZ2UiLCJmdW5jdGlvbkNhbGwiLCJmdW5jdGlvbkNhbGxSZXNwb25zZSIsInN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlIiwiY2hhdFJlcXVlc3QiLCJtdXRhdGUiLCJtdXRhdGVTdHJlYW1EYXRhIiwiZXhpc3RpbmdEYXRhIiwiZXh0cmFNZXRhZGF0YVJlZiIsIm1lc3NhZ2VzUmVmIiwic2VuZEV4dHJhTWVzc2FnZUZpZWxkcyIsIl9iIiwicHJldmlvdXNNZXNzYWdlcyIsImNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkIiwicmVhZFJvdyIsInByb21pc2UiLCJ1aSIsIm5leHQiLCJlIiwib3B0aW9ucyIsImZ1bmN0aW9ucyIsInVzZUNoYXQiLCJpbml0aWFsTWVzc2FnZXMiLCJpbml0aWFsSW5wdXQiLCJvbkVycm9yIiwiaG9va0lkIiwiY2hhdElkIiwiaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2siLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmlnZ2VyUmVxdWVzdCIsIkFib3J0Q29udHJvbGxlciIsImNoYXRSZXF1ZXN0UGFyYW0iLCJhcHBlbmQiLCJjb25jYXQiLCJyZWxvYWQiLCJsYXN0TWVzc2FnZSIsImNoYXRSZXF1ZXN0MiIsInN0b3AiLCJhYm9ydCIsInNldE1lc3NhZ2VzIiwibWVzc2FnZXMyIiwiaW5wdXQiLCJzZXRJbnB1dCIsImhhbmRsZVN1Ym1pdCIsIm1ldGFkYXRhIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVJbnB1dENoYW5nZSIsInRhcmdldCIsInVzZUNhbGxiYWNrMiIsInVzZUVmZmVjdDIiLCJ1c2VJZDIiLCJ1c2VSZWYyIiwidXNlU3RhdGUyIiwidXNlU1dSMiIsInVzZUNvbXBsZXRpb24iLCJpbml0aWFsQ29tcGxldGlvbiIsImNvbXBsZXRpb25JZCIsImNvbXBsZXRpb24iLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJwcm9tcHQiLCJhYm9ydENvbnRyb2xsZXIyIiwicmVzIiwicmVzdWx0Iiwic2V0Q29tcGxldGlvbiIsImNvbXBsZXRpb24yIiwiY29tcGxldGUiLCJ1c2VTdGF0ZTMiLCJwcm9jZXNzTWVzc2FnZVN0cmVhbSIsInByb2Nlc3NNZXNzYWdlIiwiYnVmZmVyIiwiZW5kSW5kZXgiLCJzdWJzdHJpbmciLCJ0cmltIiwiZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCIsInRocmVhZElkUGFyYW0iLCJzZXRUaHJlYWRJZCIsInN0YXR1cyIsInNldFN0YXR1cyIsInN1Ym1pdE1lc3NhZ2UiLCJlcnJvcjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ })

};
;